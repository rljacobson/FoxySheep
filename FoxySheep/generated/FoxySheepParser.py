# Generated from FoxySheep.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00bc")
        buf.write("\u01b8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\3\2\3\2\6\2")
        buf.write("\33\n\2\r\2\16\2\34\3\2\5\2 \n\2\7\2\"\n\2\f\2\16\2%\13")
        buf.write("\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3I\n\3\3\3\3\3\5\3M\n")
        buf.write("\3\3\3\5\3P\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3g\n")
        buf.write("\3\3\3\3\3\5\3k\n\3\7\3m\n\3\f\3\16\3p\13\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\5\3\u0084\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\5\3\u00c7\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u0138\n\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\6\3\u0149\n\3\r\3\16\3\u014a\3\3\3\3\3\3\5\3\u0150")
        buf.write("\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\5\3\u015f\n\3\7\3\u0161\n\3\f\3\16\3\u0164\13\3\3\4")
        buf.write("\5\4\u0167\n\4\3\4\3\4\3\5\5\5\u016c\n\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\5\5\5\u0174\n\5\3\6\3\6\3\6\5\6\u0179\n\6\3\6")
        buf.write("\5\6\u017c\n\6\3\6\3\6\5\6\u0180\n\6\3\6\5\6\u0183\n\6")
        buf.write("\5\6\u0185\n\6\3\7\3\7\3\7\3\7\5\7\u018b\n\7\5\7\u018d")
        buf.write("\n\7\3\b\3\b\5\b\u0191\n\b\3\b\3\b\3\t\3\t\5\t\u0197\n")
        buf.write("\t\3\n\3\n\3\n\3\n\3\n\5\n\u019e\n\n\3\13\5\13\u01a1\n")
        buf.write("\13\3\13\3\13\5\13\u01a5\n\13\7\13\u01a7\n\13\f\13\16")
        buf.write("\13\u01aa\13\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\5\f\u01b6\n\f\3\f\2\3\4\r\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\2\36\4\2OPRR\3\2rs\3\2\u00a0\u00a3\4\288||\4\2**jj\5")
        buf.write("\2tuxxzz\3\2\u00b0\u00b1\3\2\u00b8\u00bb\4\2))+/\3\2\60")
        buf.write("\63\3\2\'(\3\2\64\67\3\29;\3\2<=\4\2\30\30>?\3\2AB\3\2")
        buf.write("CD\3\2EH\3\2Y\\\3\2]^\3\2dg\5\2**ikmm\3\2{|\3\2\u0086")
        buf.write("\u0089\3\2LM\3\2%&\4\2\4\4\6\6\3\2\u00a0\u00a1\2\u022c")
        buf.write("\2\30\3\2\2\2\4\u0083\3\2\2\2\6\u0166\3\2\2\2\b\u0173")
        buf.write("\3\2\2\2\n\u0184\3\2\2\2\f\u018c\3\2\2\2\16\u018e\3\2")
        buf.write("\2\2\20\u0196\3\2\2\2\22\u019d\3\2\2\2\24\u01a0\3\2\2")
        buf.write("\2\26\u01b5\3\2\2\2\30#\5\4\3\2\31\33\7\u00b5\2\2\32\31")
        buf.write("\3\2\2\2\33\34\3\2\2\2\34\32\3\2\2\2\34\35\3\2\2\2\35")
        buf.write("\37\3\2\2\2\36 \5\4\3\2\37\36\3\2\2\2\37 \3\2\2\2 \"\3")
        buf.write("\2\2\2!\32\3\2\2\2\"%\3\2\2\2#!\3\2\2\2#$\3\2\2\2$\3\3")
        buf.write("\2\2\2%#\3\2\2\2&\'\b\3\1\2\'\u0084\5\n\6\2(\u0084\7\7")
        buf.write("\2\2)*\7\t\2\2*+\5\4\3\2+,\7\n\2\2,\u0084\3\2\2\2-.\7")
        buf.write("\13\2\2./\5\24\13\2/\60\7\f\2\2\60\u0084\3\2\2\2\61\62")
        buf.write("\7\22\2\2\62\63\5\24\13\2\63\64\7\23\2\2\64\u0084\3\2")
        buf.write("\2\2\65\66\7\24\2\2\66\67\5\4\3\2\678\7\25\2\28\u0084")
        buf.write("\3\2\2\29:\7\26\2\2:;\5\4\3\2;<\7\27\2\2<\u0084\3\2\2")
        buf.write("\2=>\7\34\2\2>?\5\24\13\2?@\7\35\2\2@\u0084\3\2\2\2AB")
        buf.write("\7\36\2\2BC\5\24\13\2CD\7\37\2\2D\u0084\3\2\2\2E\u0084")
        buf.write("\5\22\n\2F\u0084\5\20\t\2GI\5\6\4\2HG\3\2\2\2HI\3\2\2")
        buf.write("\2IJ\3\2\2\2JL\t\2\2\2KM\5\4\3\2LK\3\2\2\2LM\3\2\2\2M")
        buf.write("\u0084\3\2\2\2NP\5\6\4\2ON\3\2\2\2OP\3\2\2\2PQ\3\2\2\2")
        buf.write("Q\u0084\7Q\2\2R\u0084\5\6\4\2ST\7$\2\2T\u0084\7\7\2\2")
        buf.write("UV\7\u00af\2\2V\u0084\5\4\3NWX\t\3\2\2X\u0084\5\4\3LY")
        buf.write("Z\7~\2\2Z[\5\4\3\2[\\\7\177\2\2\\]\5\4\3A]\u0084\3\2\2")
        buf.write("\2^_\7\u008b\2\2_\u0084\5\4\3@`a\7\u008c\2\2a\u0084\5")
        buf.write("\4\3?bc\t\4\2\2c\u0084\5\4\39df\7\u00bc\2\2eg\5\4\3\2")
        buf.write("fe\3\2\2\2fg\3\2\2\2gn\3\2\2\2hj\7\u0084\2\2ik\5\4\3\2")
        buf.write("ji\3\2\2\2jk\3\2\2\2km\3\2\2\2lh\3\2\2\2mp\3\2\2\2nl\3")
        buf.write("\2\2\2no\3\2\2\2o\u0084\3\2\2\2pn\3\2\2\2qr\t\5\2\2r\u0084")
        buf.write("\5\4\3 st\5\6\4\2tu\7V\2\2uv\5\4\3\25v\u0084\3\2\2\2w")
        buf.write("x\5\6\4\2xy\7l\2\2yz\5\4\3\2z{\t\6\2\2{|\5\4\3\6|\u0084")
        buf.write("\3\2\2\2}~\5\6\4\2~\177\7l\2\2\177\u0080\5\4\3\2\u0080")
        buf.write("\u0081\7*\2\2\u0081\u0082\7n\2\2\u0082\u0084\3\2\2\2\u0083")
        buf.write("&\3\2\2\2\u0083(\3\2\2\2\u0083)\3\2\2\2\u0083-\3\2\2\2")
        buf.write("\u0083\61\3\2\2\2\u0083\65\3\2\2\2\u00839\3\2\2\2\u0083")
        buf.write("=\3\2\2\2\u0083A\3\2\2\2\u0083E\3\2\2\2\u0083F\3\2\2\2")
        buf.write("\u0083H\3\2\2\2\u0083O\3\2\2\2\u0083R\3\2\2\2\u0083S\3")
        buf.write("\2\2\2\u0083U\3\2\2\2\u0083W\3\2\2\2\u0083Y\3\2\2\2\u0083")
        buf.write("^\3\2\2\2\u0083`\3\2\2\2\u0083b\3\2\2\2\u0083d\3\2\2\2")
        buf.write("\u0083q\3\2\2\2\u0083s\3\2\2\2\u0083w\3\2\2\2\u0083}\3")
        buf.write("\2\2\2\u0084\u0162\3\2\2\2\u0085\u0086\fQ\2\2\u0086\u0087")
        buf.write("\7N\2\2\u0087\u0161\5\4\3R\u0088\u0089\fK\2\2\u0089\u008a")
        buf.write("\7v\2\2\u008a\u0161\5\4\3L\u008b\u008c\fJ\2\2\u008c\u008d")
        buf.write("\7y\2\2\u008d\u0161\5\4\3K\u008e\u008f\fI\2\2\u008f\u0090")
        buf.write("\7w\2\2\u0090\u0161\5\4\3I\u0091\u0092\fH\2\2\u0092\u0093")
        buf.write("\7\u008a\2\2\u0093\u0094\5\4\3\2\u0094\u0095\7\u008a\2")
        buf.write("\2\u0095\u0096\5\4\3I\u0096\u0161\3\2\2\2\u0097\u0098")
        buf.write("\fG\2\2\u0098\u0099\t\7\2\2\u0099\u0161\5\4\3G\u009a\u009b")
        buf.write("\fC\2\2\u009b\u009c\7}\2\2\u009c\u0161\5\4\3D\u009d\u009e")
        buf.write("\fB\2\2\u009e\u009f\7p\2\2\u009f\u0161\5\4\3B\u00a0\u00a1")
        buf.write("\f>\2\2\u00a1\u00a2\7\u008d\2\2\u00a2\u0161\5\4\3?\u00a3")
        buf.write("\u00a4\f=\2\2\u00a4\u00a5\7\u008e\2\2\u00a5\u0161\5\4")
        buf.write("\3>\u00a6\u00a7\f<\2\2\u00a7\u00a8\7\u008f\2\2\u00a8\u0161")
        buf.write("\5\4\3=\u00a9\u00aa\f;\2\2\u00aa\u00ab\7\u0080\2\2\u00ab")
        buf.write("\u0161\5\4\3<\u00ac\u00ad\f:\2\2\u00ad\u00ae\7n\2\2\u00ae")
        buf.write("\u0161\5\4\3;\u00af\u00b0\f8\2\2\u00b0\u00b1\t\b\2\2\u00b1")
        buf.write("\u0161\5\4\39\u00b2\u00b3\f\67\2\2\u00b3\u00b4\7\u0081")
        buf.write("\2\2\u00b4\u0161\5\4\38\u00b5\u00b6\f\66\2\2\u00b6\u00b7")
        buf.write("\7\u0091\2\2\u00b7\u0161\5\4\3\67\u00b8\u00b9\f\65\2\2")
        buf.write("\u00b9\u00ba\7\u0092\2\2\u00ba\u0161\5\4\3\66\u00bb\u00bc")
        buf.write("\f\64\2\2\u00bc\u00bd\7\u0093\2\2\u00bd\u0161\5\4\3\65")
        buf.write("\u00be\u00bf\f\63\2\2\u00bf\u00c0\7\u0094\2\2\u00c0\u0161")
        buf.write("\5\4\3\64\u00c1\u00c2\f\62\2\2\u00c2\u00c3\7\u0095\2\2")
        buf.write("\u00c3\u0161\5\4\3\63\u00c4\u00c6\f\61\2\2\u00c5\u00c7")
        buf.write("\7\u00b2\2\2\u00c6\u00c5\3\2\2\2\u00c6\u00c7\3\2\2\2\u00c7")
        buf.write("\u00c8\3\2\2\2\u00c8\u0161\5\4\3\62\u00c9\u00ca\f\60\2")
        buf.write("\2\u00ca\u00cb\7\u0096\2\2\u00cb\u0161\5\4\3\61\u00cc")
        buf.write("\u00cd\f/\2\2\u00cd\u00ce\7\u0097\2\2\u00ce\u0161\5\4")
        buf.write("\3\60\u00cf\u00d0\f.\2\2\u00d0\u00d1\7\u0098\2\2\u00d1")
        buf.write("\u0161\5\4\3/\u00d2\u00d3\f-\2\2\u00d3\u00d4\7\u0099\2")
        buf.write("\2\u00d4\u0161\5\4\3.\u00d5\u00d6\f,\2\2\u00d6\u00d7\7")
        buf.write("\u009a\2\2\u00d7\u0161\5\4\3-\u00d8\u00d9\f+\2\2\u00d9")
        buf.write("\u00da\7\u009b\2\2\u00da\u0161\5\4\3,\u00db\u00dc\f*\2")
        buf.write("\2\u00dc\u00dd\7\u009c\2\2\u00dd\u0161\5\4\3+\u00de\u00df")
        buf.write("\f)\2\2\u00df\u00e0\t\t\2\2\u00e0\u0161\5\4\3*\u00e1\u00e2")
        buf.write("\f(\2\2\u00e2\u00e3\7\u0082\2\2\u00e3\u0161\5\4\3)\u00e4")
        buf.write("\u00e5\f\'\2\2\u00e5\u00e6\7\u0083\2\2\u00e6\u0161\5\4")
        buf.write("\3(\u00e7\u00e8\f$\2\2\u00e8\u00e9\t\n\2\2\u00e9\u0161")
        buf.write("\5\4\3%\u00ea\u00eb\f#\2\2\u00eb\u00ec\t\13\2\2\u00ec")
        buf.write("\u0161\5\4\3$\u00ed\u00ee\f\"\2\2\u00ee\u00ef\t\f\2\2")
        buf.write("\u00ef\u0161\5\4\3#\u00f0\u00f1\f!\2\2\u00f1\u00f2\t\r")
        buf.write("\2\2\u00f2\u0161\5\4\3\"\u00f3\u00f4\f\37\2\2\u00f4\u00f5")
        buf.write("\t\16\2\2\u00f5\u0161\5\4\3 \u00f6\u00f7\f\36\2\2\u00f7")
        buf.write("\u00f8\t\17\2\2\u00f8\u0161\5\4\3\37\u00f9\u00fa\f\35")
        buf.write("\2\2\u00fa\u00fb\t\20\2\2\u00fb\u0161\5\4\3\36\u00fc\u00fd")
        buf.write("\f\34\2\2\u00fd\u00fe\7@\2\2\u00fe\u0161\5\4\3\35\u00ff")
        buf.write("\u0100\f\33\2\2\u0100\u0101\t\21\2\2\u0101\u0161\5\4\3")
        buf.write("\33\u0102\u0103\f\32\2\2\u0103\u0104\t\22\2\2\u0104\u0161")
        buf.write("\5\4\3\32\u0105\u0106\f\31\2\2\u0106\u0107\t\23\2\2\u0107")
        buf.write("\u0161\5\4\3\32\u0108\u0109\f\30\2\2\u0109\u010a\7I\2")
        buf.write("\2\u010a\u0161\5\4\3\30\u010b\u010c\f\26\2\2\u010c\u010d")
        buf.write("\7\31\2\2\u010d\u0161\5\4\3\27\u010e\u010f\f\24\2\2\u010f")
        buf.write("\u0110\7V\2\2\u0110\u0161\5\4\3\25\u0111\u0112\f\23\2")
        buf.write("\2\u0112\u0113\7W\2\2\u0113\u0161\5\4\3\24\u0114\u0115")
        buf.write("\f\22\2\2\u0115\u0116\7X\2\2\u0116\u0161\5\4\3\23\u0117")
        buf.write("\u0118\f\21\2\2\u0118\u0119\t\24\2\2\u0119\u0161\5\4\3")
        buf.write("\21\u011a\u011b\f\20\2\2\u011b\u011c\t\25\2\2\u011c\u0161")
        buf.write("\5\4\3\21\u011d\u011e\f\17\2\2\u011e\u011f\t\26\2\2\u011f")
        buf.write("\u0161\5\4\3\17\u0120\u0121\f\r\2\2\u0121\u0122\7\u009d")
        buf.write("\2\2\u0122\u0161\5\4\3\16\u0123\u0124\f\f\2\2\u0124\u0125")
        buf.write("\7\u009e\2\2\u0125\u0161\5\4\3\r\u0126\u0127\f\13\2\2")
        buf.write("\u0127\u0128\7\u009f\2\2\u0128\u0161\5\4\3\f\u0129\u012a")
        buf.write("\f\n\2\2\u012a\u012b\7J\2\2\u012b\u0161\5\4\3\n\u012c")
        buf.write("\u012d\f\t\2\2\u012d\u012e\7K\2\2\u012e\u0161\5\4\3\n")
        buf.write("\u012f\u0130\f\7\2\2\u0130\u0131\t\27\2\2\u0131\u0161")
        buf.write("\5\4\3\7\u0132\u0133\fX\2\2\u0133\u0134\7U\2\2\u0134\u0137")
        buf.write("\7\7\2\2\u0135\u0136\7U\2\2\u0136\u0138\7\7\2\2\u0137")
        buf.write("\u0135\3\2\2\2\u0137\u0138\3\2\2\2\u0138\u0161\3\2\2\2")
        buf.write("\u0139\u013a\fP\2\2\u013a\u013b\7\r\2\2\u013b\u013c\5")
        buf.write("\24\13\2\u013c\u013d\7\16\2\2\u013d\u0161\3\2\2\2\u013e")
        buf.write("\u013f\fO\2\2\u013f\u0161\5\26\f\2\u0140\u0141\fM\2\2")
        buf.write("\u0141\u0161\t\3\2\2\u0142\u0143\fF\2\2\u0143\u0161\t")
        buf.write("\30\2\2\u0144\u0145\fE\2\2\u0145\u0161\t\31\2\2\u0146")
        buf.write("\u0148\fD\2\2\u0147\u0149\7\"\2\2\u0148\u0147\3\2\2\2")
        buf.write("\u0149\u014a\3\2\2\2\u014a\u0148\3\2\2\2\u014a\u014b\3")
        buf.write("\2\2\2\u014b\u0161\3\2\2\2\u014c\u014d\f&\2\2\u014d\u014f")
        buf.write("\7\u0084\2\2\u014e\u0150\5\4\3\2\u014f\u014e\3\2\2\2\u014f")
        buf.write("\u0150\3\2\2\2\u0150\u0161\3\2\2\2\u0151\u0152\f\27\2")
        buf.write("\2\u0152\u0161\t\32\2\2\u0153\u0154\f\16\2\2\u0154\u0161")
        buf.write("\7h\2\2\u0155\u0156\f\b\2\2\u0156\u0157\7*\2\2\u0157\u0161")
        buf.write("\7n\2\2\u0158\u0159\f\4\2\2\u0159\u015a\t\33\2\2\u015a")
        buf.write("\u0161\7\7\2\2\u015b\u015c\f\3\2\2\u015c\u015e\7\u0085")
        buf.write("\2\2\u015d\u015f\5\4\3\2\u015e\u015d\3\2\2\2\u015e\u015f")
        buf.write("\3\2\2\2\u015f\u0161\3\2\2\2\u0160\u0085\3\2\2\2\u0160")
        buf.write("\u0088\3\2\2\2\u0160\u008b\3\2\2\2\u0160\u008e\3\2\2\2")
        buf.write("\u0160\u0091\3\2\2\2\u0160\u0097\3\2\2\2\u0160\u009a\3")
        buf.write("\2\2\2\u0160\u009d\3\2\2\2\u0160\u00a0\3\2\2\2\u0160\u00a3")
        buf.write("\3\2\2\2\u0160\u00a6\3\2\2\2\u0160\u00a9\3\2\2\2\u0160")
        buf.write("\u00ac\3\2\2\2\u0160\u00af\3\2\2\2\u0160\u00b2\3\2\2\2")
        buf.write("\u0160\u00b5\3\2\2\2\u0160\u00b8\3\2\2\2\u0160\u00bb\3")
        buf.write("\2\2\2\u0160\u00be\3\2\2\2\u0160\u00c1\3\2\2\2\u0160\u00c4")
        buf.write("\3\2\2\2\u0160\u00c9\3\2\2\2\u0160\u00cc\3\2\2\2\u0160")
        buf.write("\u00cf\3\2\2\2\u0160\u00d2\3\2\2\2\u0160\u00d5\3\2\2\2")
        buf.write("\u0160\u00d8\3\2\2\2\u0160\u00db\3\2\2\2\u0160\u00de\3")
        buf.write("\2\2\2\u0160\u00e1\3\2\2\2\u0160\u00e4\3\2\2\2\u0160\u00e7")
        buf.write("\3\2\2\2\u0160\u00ea\3\2\2\2\u0160\u00ed\3\2\2\2\u0160")
        buf.write("\u00f0\3\2\2\2\u0160\u00f3\3\2\2\2\u0160\u00f6\3\2\2\2")
        buf.write("\u0160\u00f9\3\2\2\2\u0160\u00fc\3\2\2\2\u0160\u00ff\3")
        buf.write("\2\2\2\u0160\u0102\3\2\2\2\u0160\u0105\3\2\2\2\u0160\u0108")
        buf.write("\3\2\2\2\u0160\u010b\3\2\2\2\u0160\u010e\3\2\2\2\u0160")
        buf.write("\u0111\3\2\2\2\u0160\u0114\3\2\2\2\u0160\u0117\3\2\2\2")
        buf.write("\u0160\u011a\3\2\2\2\u0160\u011d\3\2\2\2\u0160\u0120\3")
        buf.write("\2\2\2\u0160\u0123\3\2\2\2\u0160\u0126\3\2\2\2\u0160\u0129")
        buf.write("\3\2\2\2\u0160\u012c\3\2\2\2\u0160\u012f\3\2\2\2\u0160")
        buf.write("\u0132\3\2\2\2\u0160\u0139\3\2\2\2\u0160\u013e\3\2\2\2")
        buf.write("\u0160\u0140\3\2\2\2\u0160\u0142\3\2\2\2\u0160\u0144\3")
        buf.write("\2\2\2\u0160\u0146\3\2\2\2\u0160\u014c\3\2\2\2\u0160\u0151")
        buf.write("\3\2\2\2\u0160\u0153\3\2\2\2\u0160\u0155\3\2\2\2\u0160")
        buf.write("\u0158\3\2\2\2\u0160\u015b\3\2\2\2\u0161\u0164\3\2\2\2")
        buf.write("\u0162\u0160\3\2\2\2\u0162\u0163\3\2\2\2\u0163\5\3\2\2")
        buf.write("\2\u0164\u0162\3\2\2\2\u0165\u0167\5\b\5\2\u0166\u0165")
        buf.write("\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u0168\3\2\2\2\u0168")
        buf.write("\u0169\7\3\2\2\u0169\7\3\2\2\2\u016a\u016c\7!\2\2\u016b")
        buf.write("\u016a\3\2\2\2\u016b\u016c\3\2\2\2\u016c\u016d\3\2\2\2")
        buf.write("\u016d\u016e\7\3\2\2\u016e\u0174\7!\2\2\u016f\u0170\7")
        buf.write("\3\2\2\u0170\u0171\7!\2\2\u0171\u0172\7\3\2\2\u0172\u0174")
        buf.write("\7!\2\2\u0173\u016b\3\2\2\2\u0173\u016f\3\2\2\2\u0174")
        buf.write("\t\3\2\2\2\u0175\u0176\7\6\2\2\u0176\u0178\7\5\2\2\u0177")
        buf.write("\u0179\5\f\7\2\u0178\u0177\3\2\2\2\u0178\u0179\3\2\2\2")
        buf.write("\u0179\u017b\3\2\2\2\u017a\u017c\5\16\b\2\u017b\u017a")
        buf.write("\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u0185\3\2\2\2\u017d")
        buf.write("\u017f\t\34\2\2\u017e\u0180\5\f\7\2\u017f\u017e\3\2\2")
        buf.write("\2\u017f\u0180\3\2\2\2\u0180\u0182\3\2\2\2\u0181\u0183")
        buf.write("\5\16\b\2\u0182\u0181\3\2\2\2\u0182\u0183\3\2\2\2\u0183")
        buf.write("\u0185\3\2\2\2\u0184\u0175\3\2\2\2\u0184\u017d\3\2\2\2")
        buf.write("\u0185\13\3\2\2\2\u0186\u0187\7 \2\2\u0187\u018d\t\34")
        buf.write("\2\2\u0188\u018a\7!\2\2\u0189\u018b\t\34\2\2\u018a\u0189")
        buf.write("\3\2\2\2\u018a\u018b\3\2\2\2\u018b\u018d\3\2\2\2\u018c")
        buf.write("\u0186\3\2\2\2\u018c\u0188\3\2\2\2\u018d\r\3\2\2\2\u018e")
        buf.write("\u0190\7q\2\2\u018f\u0191\t\35\2\2\u0190\u018f\3\2\2\2")
        buf.write("\u0190\u0191\3\2\2\2\u0191\u0192\3\2\2\2\u0192\u0193\7")
        buf.write("\6\2\2\u0193\17\3\2\2\2\u0194\u0197\7S\2\2\u0195\u0197")
        buf.write("\7T\2\2\u0196\u0194\3\2\2\2\u0196\u0195\3\2\2\2\u0197")
        buf.write("\21\3\2\2\2\u0198\u019e\7_\2\2\u0199\u019e\7`\2\2\u019a")
        buf.write("\u019e\7a\2\2\u019b\u019e\7b\2\2\u019c\u019e\7c\2\2\u019d")
        buf.write("\u0198\3\2\2\2\u019d\u0199\3\2\2\2\u019d\u019a\3\2\2\2")
        buf.write("\u019d\u019b\3\2\2\2\u019d\u019c\3\2\2\2\u019e\23\3\2")
        buf.write("\2\2\u019f\u01a1\5\4\3\2\u01a0\u019f\3\2\2\2\u01a0\u01a1")
        buf.write("\3\2\2\2\u01a1\u01a8\3\2\2\2\u01a2\u01a4\7\17\2\2\u01a3")
        buf.write("\u01a5\5\4\3\2\u01a4\u01a3\3\2\2\2\u01a4\u01a5\3\2\2\2")
        buf.write("\u01a5\u01a7\3\2\2\2\u01a6\u01a2\3\2\2\2\u01a7\u01aa\3")
        buf.write("\2\2\2\u01a8\u01a6\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9\25")
        buf.write("\3\2\2\2\u01aa\u01a8\3\2\2\2\u01ab\u01ac\7\r\2\2\u01ac")
        buf.write("\u01ad\7\r\2\2\u01ad\u01ae\5\24\13\2\u01ae\u01af\7\16")
        buf.write("\2\2\u01af\u01b0\7\16\2\2\u01b0\u01b6\3\2\2\2\u01b1\u01b2")
        buf.write("\7\32\2\2\u01b2\u01b3\5\24\13\2\u01b3\u01b4\7\33\2\2\u01b4")
        buf.write("\u01b6\3\2\2\2\u01b5\u01ab\3\2\2\2\u01b5\u01b1\3\2\2\2")
        buf.write("\u01b6\27\3\2\2\2$\34\37#HLOfjn\u0083\u00c6\u0137\u014a")
        buf.write("\u014f\u015e\u0160\u0162\u0166\u016b\u0173\u0178\u017b")
        buf.write("\u017f\u0182\u0184\u018a\u018c\u0190\u0196\u019d\u01a0")
        buf.write("\u01a4\u01a8\u01b5")
        return buf.getvalue()


class FoxySheepParser ( Parser ):

    grammarFileName = "FoxySheep.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "'{'", "'}'", "'['", "']'", "','", "'(*'", "'*)'", 
                     "'\u2329'", "'\u232A'", "'\u230A'", "'\u230B'", "'\u2308'", 
                     "'\u2309'", "'||'", "'|'", "'\u301A'", "'\u301B'", 
                     "'\uF603'", "'\uF604'", "'\uF605'", "'\uF606'", "'``'", 
                     "'`'", "'''", "'\"'", "'<<'", "'>>>'", "'>>'", "'==='", 
                     "'=!='", "<INVALID>", "'='", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'<'", "'>'", "'\uF3D0'", "'\uF3D1'", 
                     "'\u2225'", "'\u2226'", "'\u2208'", "'\u2209'", "'\u2282'", 
                     "'\u2283'", "'\u00AC'", "'&&'", "'\u2227'", "'\u22BC'", 
                     "'\u22BB'", "'\uF4A2'", "'\u2228'", "'\u22BD'", "'\u29E6'", 
                     "'\uF523'", "'\u2970'", "'\u22A2'", "'\u22A8'", "'\u22A3'", 
                     "'\u2AE4'", "'\u22A5'", "'\u22A4'", "'\u220D'", "'\u2234'", 
                     "'\u2235'", "'...'", "'..'", "'?'", "'___'", "'__'", 
                     "'_.'", "'_'", "<INVALID>", "<INVALID>", "'::'", "':'", 
                     "'~~'", "'/;'", "'->'", "'\uF522'", "':>'", "'\uF51F'", 
                     "'/.'", "'//.'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'##'", "'#'", "'+='", "'-='", "'*='", "'/='", "'&'", 
                     "'^:='", "':='", "'^='", "'/:'", "'\uF4A1'", "'.'", 
                     "'^^'", "'^'", "'*^'", "'++'", "'--'", "'@@@'", "'@@'", 
                     "'@*'", "'@'", "'/@'", "'/*'", "'//@'", "'!!'", "'!'", 
                     "'<>'", "'\u222B'", "'\uF74C'", "'\uF4A0'", "'\\'", 
                     "'\u22C2'", "'\u22C3'", "';;'", "';'", "'\uF3C7'", 
                     "'\uF3C9'", "'\uF3CE'", "'\uF3C8'", "'~'", "'\u2207'", 
                     "'\uF520'", "'\u2218'", "'\u2299'", "'**'", "'\u2216'", 
                     "'\u22C4'", "'\u22C0'", "'\u22C1'", "'\u2297'", "'\u00B7'", 
                     "'\u22C6'", "'\u2240'", "'\u2210'", "'\u2322'", "'\u2323'", 
                     "'\u2295'", "'\u2296'", "'\u2236'", "'//'", "'\uF432'", 
                     "'+'", "'-'", "'\u00B1'", "'\u2213'", "'\\`'", "'\\!'", 
                     "'\\/'", "'\\('", "'\\%'", "'\\&'", "'\\)'", "'\\@'", 
                     "'\\_'", "'\\^'", "'\\+'", "'\\*'", "'/'", "'\u00F7'", 
                     "<INVALID>", "'*'", "'\u00D7'", "'\n'", "'\uF3B1'" ]

    symbolicNames = [ "<INVALID>", "Name", "DecimalNumber", "NumberInBase", 
                      "DIGITS", "StringLiteral", "COMMENT", "LPAREN", "RPAREN", 
                      "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "COMMA", 
                      "LCOMMENT", "RCOMMENT", "LANGLE", "RANGLE", "LFLOOR", 
                      "RFLOOR", "LCEILING", "RCEILING", "DOUBLEBAR", "BAR", 
                      "LBARBRACKET", "RBARBRACKET", "LBRACKETINGBAR", "RBRACKETINGBAR", 
                      "LDOUBLEBRACKETINGBAR", "RDOUBLEBRACKETINGBAR", "DOUBLEBACKQUOTE", 
                      "BACKQUOTE", "SINGLEQUOTE", "QUOTE", "DOUBLELESS", 
                      "TRIPPLEGREATER", "DOUBLEGREATER", "TRIPPLEEQUAL", 
                      "EQUALBANGEQUAL", "EqualSymbol", "EQUAL", "NotEqualSymbol", 
                      "GreaterEqualSymbol", "LessEqualSymbol", "LESS", "GREATER", 
                      "VERTICALBAR", "NOTVERTICALBAR", "DOUBLEVERTICALBAR", 
                      "NOTDOUBLEVERTICALBAR", "ELEMENT", "NOTELEMENT", "SUBSET", 
                      "SUPERSET", "NOT", "DOUBLEAMP", "AND", "NAND", "XOR", 
                      "XNOR", "OR", "NOR", "LRDOUBLEARROW", "RDOUBLEARROW", 
                      "LCONTAINS", "RIGHTTEE", "DOUBLERIGHTTEE", "LEFTTEE", 
                      "DOUBLELEFTTEE", "UPTEE", "DOWNTEE", "SUCHTHAT", "THEREFORE", 
                      "BECAUSE", "TRIPPLEDOT", "DOUBLEDOT", "QUESTIONMARK", 
                      "TRIPPLEBLANK", "DOUBLEBLANK", "BLANKDOT", "BLANK", 
                      "PERCENTDIGITS", "PERCENTS", "DOUBLECOLON", "RAWCOLON", 
                      "DOUBLETILDE", "SLASHSEMI", "MINUSGREATER", "RARROW", 
                      "COLONGREATER", "COLONARROW", "SLASHDOT", "DOUBLESLASHDOT", 
                      "HASHDIGITS", "HASHStringLiteral", "DOUBLEHASHDIGITS", 
                      "DOUBLEHASH", "HASH", "PLUSEQUAL", "MINUSEQUAL", "ASTERISKEQUAL", 
                      "SLASHEQUAL", "AMP", "CARETCOLONEQUAL", "COLONEQUAL", 
                      "CARETEQUAL", "SLASHCOLON", "FUNCTIONARROW", "DOT", 
                      "DOUBLECARET", "CARET", "ASTERISKCARET", "DOUBLEPLUS", 
                      "DOUBLEMINUS", "TRIPPLEAT", "DOUBLEAT", "ATASTERISK", 
                      "AT", "MAP", "SLASHASTERISK", "MAPALL", "DOUBLEBANG", 
                      "BANG", "LESSGREATER", "INTEGRAL", "DIFFERENTIALD", 
                      "CROSS", "RAWBACKSLASH", "INTERSECTION", "UNION", 
                      "DOUBLESEMICOLON", "SEMICOLON", "TRANSPOSE", "CONJUGATETRANSPOSE", 
                      "HERMITIANCONJUGATE", "CONJUGATE", "TILDE", "DEL", 
                      "SQUARE", "SMALLCIRCLE", "CIRCLEDOT", "DOUBLEASTERISK", 
                      "BACKSLASH", "DIAMOND", "WEDGE", "VEE", "CIRCLETIMES", 
                      "CENTERDOT", "STAR", "VERTICALTILDE", "COPRODUCT", 
                      "CAP", "CUP", "CIRCLEPLUS", "CIRCLEMINUS", "COLON", 
                      "DOUBLESLASH", "VERTICALSEPARATOR", "PLUS", "MINUS", 
                      "PLUSMINUS", "MINUSPLUS", "FormBox", "InterpretedBox", 
                      "BoxFraction", "BoxLeftBoxParenthesis", "BoxOtherscript", 
                      "BoxOverscript", "BoxRightBoxParenthesis", "BoxSqrt", 
                      "BoxSubscript", "BoxSuperscript", "BoxUnderscript", 
                      "BoxConstructor", "SLASH", "DIVIDE", "MultiplicationSymbol", 
                      "ASTERISK", "TIMES", "NEWLINE", "CONTINUATION", "WHITESPACE", 
                      "BINARYPLUS", "BINARYMINUS", "BINARYMINUSPLUS", "BINARYPLUSMINUS", 
                      "SPANSEMICOLONS" ]

    RULE_prog = 0
    RULE_expr = 1
    RULE_symbol = 2
    RULE_context = 3
    RULE_numberLiteral = 4
    RULE_numberLiteralPrecision = 5
    RULE_numberLiteralExponent = 6
    RULE_outExpression = 7
    RULE_slotExpression = 8
    RULE_expressionList = 9
    RULE_accessExpression = 10

    ruleNames =  [ "prog", "expr", "symbol", "context", "numberLiteral", 
                   "numberLiteralPrecision", "numberLiteralExponent", "outExpression", 
                   "slotExpression", "expressionList", "accessExpression" ]

    EOF = Token.EOF
    Name=1
    DecimalNumber=2
    NumberInBase=3
    DIGITS=4
    StringLiteral=5
    COMMENT=6
    LPAREN=7
    RPAREN=8
    LBRACE=9
    RBRACE=10
    LBRACKET=11
    RBRACKET=12
    COMMA=13
    LCOMMENT=14
    RCOMMENT=15
    LANGLE=16
    RANGLE=17
    LFLOOR=18
    RFLOOR=19
    LCEILING=20
    RCEILING=21
    DOUBLEBAR=22
    BAR=23
    LBARBRACKET=24
    RBARBRACKET=25
    LBRACKETINGBAR=26
    RBRACKETINGBAR=27
    LDOUBLEBRACKETINGBAR=28
    RDOUBLEBRACKETINGBAR=29
    DOUBLEBACKQUOTE=30
    BACKQUOTE=31
    SINGLEQUOTE=32
    QUOTE=33
    DOUBLELESS=34
    TRIPPLEGREATER=35
    DOUBLEGREATER=36
    TRIPPLEEQUAL=37
    EQUALBANGEQUAL=38
    EqualSymbol=39
    EQUAL=40
    NotEqualSymbol=41
    GreaterEqualSymbol=42
    LessEqualSymbol=43
    LESS=44
    GREATER=45
    VERTICALBAR=46
    NOTVERTICALBAR=47
    DOUBLEVERTICALBAR=48
    NOTDOUBLEVERTICALBAR=49
    ELEMENT=50
    NOTELEMENT=51
    SUBSET=52
    SUPERSET=53
    NOT=54
    DOUBLEAMP=55
    AND=56
    NAND=57
    XOR=58
    XNOR=59
    OR=60
    NOR=61
    LRDOUBLEARROW=62
    RDOUBLEARROW=63
    LCONTAINS=64
    RIGHTTEE=65
    DOUBLERIGHTTEE=66
    LEFTTEE=67
    DOUBLELEFTTEE=68
    UPTEE=69
    DOWNTEE=70
    SUCHTHAT=71
    THEREFORE=72
    BECAUSE=73
    TRIPPLEDOT=74
    DOUBLEDOT=75
    QUESTIONMARK=76
    TRIPPLEBLANK=77
    DOUBLEBLANK=78
    BLANKDOT=79
    BLANK=80
    PERCENTDIGITS=81
    PERCENTS=82
    DOUBLECOLON=83
    RAWCOLON=84
    DOUBLETILDE=85
    SLASHSEMI=86
    MINUSGREATER=87
    RARROW=88
    COLONGREATER=89
    COLONARROW=90
    SLASHDOT=91
    DOUBLESLASHDOT=92
    HASHDIGITS=93
    HASHStringLiteral=94
    DOUBLEHASHDIGITS=95
    DOUBLEHASH=96
    HASH=97
    PLUSEQUAL=98
    MINUSEQUAL=99
    ASTERISKEQUAL=100
    SLASHEQUAL=101
    AMP=102
    CARETCOLONEQUAL=103
    COLONEQUAL=104
    CARETEQUAL=105
    SLASHCOLON=106
    FUNCTIONARROW=107
    DOT=108
    DOUBLECARET=109
    CARET=110
    ASTERISKCARET=111
    DOUBLEPLUS=112
    DOUBLEMINUS=113
    TRIPPLEAT=114
    DOUBLEAT=115
    ATASTERISK=116
    AT=117
    MAP=118
    SLASHASTERISK=119
    MAPALL=120
    DOUBLEBANG=121
    BANG=122
    LESSGREATER=123
    INTEGRAL=124
    DIFFERENTIALD=125
    CROSS=126
    RAWBACKSLASH=127
    INTERSECTION=128
    UNION=129
    DOUBLESEMICOLON=130
    SEMICOLON=131
    TRANSPOSE=132
    CONJUGATETRANSPOSE=133
    HERMITIANCONJUGATE=134
    CONJUGATE=135
    TILDE=136
    DEL=137
    SQUARE=138
    SMALLCIRCLE=139
    CIRCLEDOT=140
    DOUBLEASTERISK=141
    BACKSLASH=142
    DIAMOND=143
    WEDGE=144
    VEE=145
    CIRCLETIMES=146
    CENTERDOT=147
    STAR=148
    VERTICALTILDE=149
    COPRODUCT=150
    CAP=151
    CUP=152
    CIRCLEPLUS=153
    CIRCLEMINUS=154
    COLON=155
    DOUBLESLASH=156
    VERTICALSEPARATOR=157
    PLUS=158
    MINUS=159
    PLUSMINUS=160
    MINUSPLUS=161
    FormBox=162
    InterpretedBox=163
    BoxFraction=164
    BoxLeftBoxParenthesis=165
    BoxOtherscript=166
    BoxOverscript=167
    BoxRightBoxParenthesis=168
    BoxSqrt=169
    BoxSubscript=170
    BoxSuperscript=171
    BoxUnderscript=172
    BoxConstructor=173
    SLASH=174
    DIVIDE=175
    MultiplicationSymbol=176
    ASTERISK=177
    TIMES=178
    NEWLINE=179
    CONTINUATION=180
    WHITESPACE=181
    BINARYPLUS=182
    BINARYMINUS=183
    BINARYMINUSPLUS=184
    BINARYPLUSMINUS=185
    SPANSEMICOLONS=186

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.NEWLINE)
            else:
                return self.getToken(FoxySheepParser.NEWLINE, i)

        def getRuleIndex(self):
            return FoxySheepParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = FoxySheepParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 22
            self.expr(0)
            self.state = 33
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==FoxySheepParser.NEWLINE:
                self.state = 24 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 23
                        self.match(FoxySheepParser.NEWLINE)

                    else:
                        raise NoViableAltException(self)
                    self.state = 26 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

                self.state = 29
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.Name) | (1 << FoxySheepParser.DecimalNumber) | (1 << FoxySheepParser.DIGITS) | (1 << FoxySheepParser.StringLiteral) | (1 << FoxySheepParser.LPAREN) | (1 << FoxySheepParser.LBRACE) | (1 << FoxySheepParser.LANGLE) | (1 << FoxySheepParser.LFLOOR) | (1 << FoxySheepParser.LCEILING) | (1 << FoxySheepParser.LBRACKETINGBAR) | (1 << FoxySheepParser.LDOUBLEBRACKETINGBAR) | (1 << FoxySheepParser.BACKQUOTE) | (1 << FoxySheepParser.DOUBLELESS) | (1 << FoxySheepParser.NOT))) != 0) or ((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & ((1 << (FoxySheepParser.TRIPPLEBLANK - 77)) | (1 << (FoxySheepParser.DOUBLEBLANK - 77)) | (1 << (FoxySheepParser.BLANKDOT - 77)) | (1 << (FoxySheepParser.BLANK - 77)) | (1 << (FoxySheepParser.PERCENTDIGITS - 77)) | (1 << (FoxySheepParser.PERCENTS - 77)) | (1 << (FoxySheepParser.HASHDIGITS - 77)) | (1 << (FoxySheepParser.HASHStringLiteral - 77)) | (1 << (FoxySheepParser.DOUBLEHASHDIGITS - 77)) | (1 << (FoxySheepParser.DOUBLEHASH - 77)) | (1 << (FoxySheepParser.HASH - 77)) | (1 << (FoxySheepParser.DOUBLEPLUS - 77)) | (1 << (FoxySheepParser.DOUBLEMINUS - 77)) | (1 << (FoxySheepParser.BANG - 77)) | (1 << (FoxySheepParser.INTEGRAL - 77)) | (1 << (FoxySheepParser.DEL - 77)) | (1 << (FoxySheepParser.SQUARE - 77)))) != 0) or ((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & ((1 << (FoxySheepParser.PLUS - 158)) | (1 << (FoxySheepParser.MINUS - 158)) | (1 << (FoxySheepParser.PLUSMINUS - 158)) | (1 << (FoxySheepParser.MINUSPLUS - 158)) | (1 << (FoxySheepParser.BoxConstructor - 158)) | (1 << (FoxySheepParser.SPANSEMICOLONS - 158)))) != 0):
                    self.state = 28
                    self.expr(0)


                self.state = 35
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PatternExpContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)

        def RAWCOLON(self):
            return self.getToken(FoxySheepParser.RAWCOLON, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternExp" ):
                listener.enterPatternExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternExp" ):
                listener.exitPatternExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternExp" ):
                return visitor.visitPatternExp(self)
            else:
                return visitor.visitChildren(self)


    class OrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def OR(self):
            return self.getToken(FoxySheepParser.OR, 0)
        def NOR(self):
            return self.getToken(FoxySheepParser.NOR, 0)
        def DOUBLEBAR(self):
            return self.getToken(FoxySheepParser.DOUBLEBAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOr" ):
                listener.enterOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOr" ):
                listener.exitOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOr" ):
                return visitor.visitOr(self)
            else:
                return visitor.visitChildren(self)


    class ConjugateContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def CONJUGATE(self):
            return self.getToken(FoxySheepParser.CONJUGATE, 0)
        def TRANSPOSE(self):
            return self.getToken(FoxySheepParser.TRANSPOSE, 0)
        def CONJUGATETRANSPOSE(self):
            return self.getToken(FoxySheepParser.CONJUGATETRANSPOSE, 0)
        def HERMITIANCONJUGATE(self):
            return self.getToken(FoxySheepParser.HERMITIANCONJUGATE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConjugate" ):
                listener.enterConjugate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConjugate" ):
                listener.exitConjugate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConjugate" ):
                return visitor.visitConjugate(self)
            else:
                return visitor.visitChildren(self)


    class CeilingContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LCEILING(self):
            return self.getToken(FoxySheepParser.LCEILING, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def RCEILING(self):
            return self.getToken(FoxySheepParser.RCEILING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCeiling" ):
                listener.enterCeiling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCeiling" ):
                listener.exitCeiling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCeiling" ):
                return visitor.visitCeiling(self)
            else:
                return visitor.visitChildren(self)


    class InfixContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def TILDE(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.TILDE)
            else:
                return self.getToken(FoxySheepParser.TILDE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInfix" ):
                listener.enterInfix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInfix" ):
                listener.exitInfix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfix" ):
                return visitor.visitInfix(self)
            else:
                return visitor.visitChildren(self)


    class ThereforeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def THEREFORE(self):
            return self.getToken(FoxySheepParser.THEREFORE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTherefore" ):
                listener.enterTherefore(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTherefore" ):
                listener.exitTherefore(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTherefore" ):
                return visitor.visitTherefore(self)
            else:
                return visitor.visitChildren(self)


    class TagUnsetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)

        def SLASHCOLON(self):
            return self.getToken(FoxySheepParser.SLASHCOLON, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def EQUAL(self):
            return self.getToken(FoxySheepParser.EQUAL, 0)
        def DOT(self):
            return self.getToken(FoxySheepParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTagUnset" ):
                listener.enterTagUnset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTagUnset" ):
                listener.exitTagUnset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTagUnset" ):
                return visitor.visitTagUnset(self)
            else:
                return visitor.visitChildren(self)


    class AccessorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def accessExpression(self):
            return self.getTypedRuleContext(FoxySheepParser.AccessExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessor" ):
                listener.enterAccessor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessor" ):
                listener.exitAccessor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessor" ):
                return visitor.visitAccessor(self)
            else:
                return visitor.visitChildren(self)


    class CircleMinusContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CIRCLEMINUS(self):
            return self.getToken(FoxySheepParser.CIRCLEMINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCircleMinus" ):
                listener.enterCircleMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCircleMinus" ):
                listener.exitCircleMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCircleMinus" ):
                return visitor.visitCircleMinus(self)
            else:
                return visitor.visitChildren(self)


    class DivideContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SLASH(self):
            return self.getToken(FoxySheepParser.SLASH, 0)
        def DIVIDE(self):
            return self.getToken(FoxySheepParser.DIVIDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDivide" ):
                listener.enterDivide(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDivide" ):
                listener.exitDivide(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivide" ):
                return visitor.visitDivide(self)
            else:
                return visitor.visitChildren(self)


    class ImpliesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def RDOUBLEARROW(self):
            return self.getToken(FoxySheepParser.RDOUBLEARROW, 0)
        def LCONTAINS(self):
            return self.getToken(FoxySheepParser.LCONTAINS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplies" ):
                listener.enterImplies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplies" ):
                listener.exitImplies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImplies" ):
                return visitor.visitImplies(self)
            else:
                return visitor.visitChildren(self)


    class PlusOpContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def BINARYPLUS(self):
            return self.getToken(FoxySheepParser.BINARYPLUS, 0)
        def BINARYMINUS(self):
            return self.getToken(FoxySheepParser.BINARYMINUS, 0)
        def BINARYPLUSMINUS(self):
            return self.getToken(FoxySheepParser.BINARYPLUSMINUS, 0)
        def BINARYMINUSPLUS(self):
            return self.getToken(FoxySheepParser.BINARYMINUSPLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlusOp" ):
                listener.enterPlusOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlusOp" ):
                listener.exitPlusOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlusOp" ):
                return visitor.visitPlusOp(self)
            else:
                return visitor.visitChildren(self)


    class RightCompositionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SLASHASTERISK(self):
            return self.getToken(FoxySheepParser.SLASHASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightComposition" ):
                listener.enterRightComposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightComposition" ):
                listener.exitRightComposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightComposition" ):
                return visitor.visitRightComposition(self)
            else:
                return visitor.visitChildren(self)


    class NonCommutativeMultiplyContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLEASTERISK(self):
            return self.getToken(FoxySheepParser.DOUBLEASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNonCommutativeMultiply" ):
                listener.enterNonCommutativeMultiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNonCommutativeMultiply" ):
                listener.exitNonCommutativeMultiply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNonCommutativeMultiply" ):
                return visitor.visitNonCommutativeMultiply(self)
            else:
                return visitor.visitChildren(self)


    class ListContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(FoxySheepParser.LBRACE, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RBRACE(self):
            return self.getToken(FoxySheepParser.RBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList" ):
                listener.enterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList" ):
                listener.exitList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList" ):
                return visitor.visitList(self)
            else:
                return visitor.visitChildren(self)


    class CupContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CUP(self):
            return self.getToken(FoxySheepParser.CUP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCup" ):
                listener.enterCup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCup" ):
                listener.exitCup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCup" ):
                return visitor.visitCup(self)
            else:
                return visitor.visitChildren(self)


    class SameContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def TRIPPLEEQUAL(self):
            return self.getToken(FoxySheepParser.TRIPPLEEQUAL, 0)
        def EQUALBANGEQUAL(self):
            return self.getToken(FoxySheepParser.EQUALBANGEQUAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSame" ):
                listener.enterSame(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSame" ):
                listener.exitSame(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSame" ):
                return visitor.visitSame(self)
            else:
                return visitor.visitChildren(self)


    class OptionalContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def RAWCOLON(self):
            return self.getToken(FoxySheepParser.RAWCOLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptional" ):
                listener.enterOptional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptional" ):
                listener.exitOptional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptional" ):
                return visitor.visitOptional(self)
            else:
                return visitor.visitChildren(self)


    class SuchThatContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SUCHTHAT(self):
            return self.getToken(FoxySheepParser.SUCHTHAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuchThat" ):
                listener.enterSuchThat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuchThat" ):
                listener.exitSuchThat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSuchThat" ):
                return visitor.visitSuchThat(self)
            else:
                return visitor.visitChildren(self)


    class DoubleBracketingBarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LDOUBLEBRACKETINGBAR(self):
            return self.getToken(FoxySheepParser.LDOUBLEBRACKETINGBAR, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RDOUBLEBRACKETINGBAR(self):
            return self.getToken(FoxySheepParser.RDOUBLEBRACKETINGBAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleBracketingBar" ):
                listener.enterDoubleBracketingBar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleBracketingBar" ):
                listener.exitDoubleBracketingBar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoubleBracketingBar" ):
                return visitor.visitDoubleBracketingBar(self)
            else:
                return visitor.visitChildren(self)


    class PatternBlankDotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BLANKDOT(self):
            return self.getToken(FoxySheepParser.BLANKDOT, 0)
        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternBlankDot" ):
                listener.enterPatternBlankDot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternBlankDot" ):
                listener.exitPatternBlankDot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternBlankDot" ):
                return visitor.visitPatternBlankDot(self)
            else:
                return visitor.visitChildren(self)


    class DotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOT(self):
            return self.getToken(FoxySheepParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDot" ):
                listener.enterDot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDot" ):
                listener.exitDot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDot" ):
                return visitor.visitDot(self)
            else:
                return visitor.visitChildren(self)


    class VerticalBarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def VERTICALBAR(self):
            return self.getToken(FoxySheepParser.VERTICALBAR, 0)
        def NOTVERTICALBAR(self):
            return self.getToken(FoxySheepParser.NOTVERTICALBAR, 0)
        def DOUBLEVERTICALBAR(self):
            return self.getToken(FoxySheepParser.DOUBLEVERTICALBAR, 0)
        def NOTDOUBLEVERTICALBAR(self):
            return self.getToken(FoxySheepParser.NOTDOUBLEVERTICALBAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerticalBar" ):
                listener.enterVerticalBar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerticalBar" ):
                listener.exitVerticalBar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerticalBar" ):
                return visitor.visitVerticalBar(self)
            else:
                return visitor.visitChildren(self)


    class SquareContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SQUARE(self):
            return self.getToken(FoxySheepParser.SQUARE, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSquare" ):
                listener.enterSquare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSquare" ):
                listener.exitSquare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSquare" ):
                return visitor.visitSquare(self)
            else:
                return visitor.visitChildren(self)


    class AlternativesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def BAR(self):
            return self.getToken(FoxySheepParser.BAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlternatives" ):
                listener.enterAlternatives(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlternatives" ):
                listener.exitAlternatives(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlternatives" ):
                return visitor.visitAlternatives(self)
            else:
                return visitor.visitChildren(self)


    class OutContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def outExpression(self):
            return self.getTypedRuleContext(FoxySheepParser.OutExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOut" ):
                listener.enterOut(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOut" ):
                listener.exitOut(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOut" ):
                return visitor.visitOut(self)
            else:
                return visitor.visitChildren(self)


    class BoxConstructorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BoxConstructor(self):
            return self.getToken(FoxySheepParser.BoxConstructor, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoxConstructor" ):
                listener.enterBoxConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoxConstructor" ):
                listener.exitBoxConstructor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoxConstructor" ):
                return visitor.visitBoxConstructor(self)
            else:
                return visitor.visitChildren(self)


    class NotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def BANG(self):
            return self.getToken(FoxySheepParser.BANG, 0)
        def NOT(self):
            return self.getToken(FoxySheepParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNot" ):
                listener.enterNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNot" ):
                listener.exitNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot" ):
                return visitor.visitNot(self)
            else:
                return visitor.visitChildren(self)


    class PostfixContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLESLASH(self):
            return self.getToken(FoxySheepParser.DOUBLESLASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfix" ):
                listener.enterPostfix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfix" ):
                listener.exitPostfix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfix" ):
                return visitor.visitPostfix(self)
            else:
                return visitor.visitChildren(self)


    class PatternBlanksContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRIPPLEBLANK(self):
            return self.getToken(FoxySheepParser.TRIPPLEBLANK, 0)
        def DOUBLEBLANK(self):
            return self.getToken(FoxySheepParser.DOUBLEBLANK, 0)
        def BLANK(self):
            return self.getToken(FoxySheepParser.BLANK, 0)
        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternBlanks" ):
                listener.enterPatternBlanks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternBlanks" ):
                listener.exitPatternBlanks(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternBlanks" ):
                return visitor.visitPatternBlanks(self)
            else:
                return visitor.visitChildren(self)


    class UnaryPlusMinusContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def MINUS(self):
            return self.getToken(FoxySheepParser.MINUS, 0)
        def PLUS(self):
            return self.getToken(FoxySheepParser.PLUS, 0)
        def PLUSMINUS(self):
            return self.getToken(FoxySheepParser.PLUSMINUS, 0)
        def MINUSPLUS(self):
            return self.getToken(FoxySheepParser.MINUSPLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlusMinus" ):
                listener.enterUnaryPlusMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlusMinus" ):
                listener.exitUnaryPlusMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryPlusMinus" ):
                return visitor.visitUnaryPlusMinus(self)
            else:
                return visitor.visitChildren(self)


    class CapContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CAP(self):
            return self.getToken(FoxySheepParser.CAP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCap" ):
                listener.enterCap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCap" ):
                listener.exitCap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCap" ):
                return visitor.visitCap(self)
            else:
                return visitor.visitChildren(self)


    class CirclePlusContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CIRCLEPLUS(self):
            return self.getToken(FoxySheepParser.CIRCLEPLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCirclePlus" ):
                listener.enterCirclePlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCirclePlus" ):
                listener.exitCirclePlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCirclePlus" ):
                return visitor.visitCirclePlus(self)
            else:
                return visitor.visitChildren(self)


    class BecauseContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def BECAUSE(self):
            return self.getToken(FoxySheepParser.BECAUSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBecause" ):
                listener.enterBecause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBecause" ):
                listener.exitBecause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBecause" ):
                return visitor.visitBecause(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def StringLiteral(self):
            return self.getToken(FoxySheepParser.StringLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class AndContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLEAMP(self):
            return self.getToken(FoxySheepParser.DOUBLEAMP, 0)
        def AND(self):
            return self.getToken(FoxySheepParser.AND, 0)
        def NAND(self):
            return self.getToken(FoxySheepParser.NAND, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnd" ):
                listener.enterAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnd" ):
                listener.exitAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnd" ):
                return visitor.visitAnd(self)
            else:
                return visitor.visitChildren(self)


    class GetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLELESS(self):
            return self.getToken(FoxySheepParser.DOUBLELESS, 0)
        def StringLiteral(self):
            return self.getToken(FoxySheepParser.StringLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGet" ):
                listener.enterGet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGet" ):
                listener.exitGet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGet" ):
                return visitor.visitGet(self)
            else:
                return visitor.visitChildren(self)


    class EquivalentContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def LRDOUBLEARROW(self):
            return self.getToken(FoxySheepParser.LRDOUBLEARROW, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquivalent" ):
                listener.enterEquivalent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquivalent" ):
                listener.exitEquivalent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquivalent" ):
                return visitor.visitEquivalent(self)
            else:
                return visitor.visitChildren(self)


    class CompoundExpressionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SEMICOLON(self):
            return self.getToken(FoxySheepParser.SEMICOLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundExpression" ):
                listener.enterCompoundExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundExpression" ):
                listener.exitCompoundExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundExpression" ):
                return visitor.visitCompoundExpression(self)
            else:
                return visitor.visitChildren(self)


    class DerivativeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def SINGLEQUOTE(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.SINGLEQUOTE)
            else:
                return self.getToken(FoxySheepParser.SINGLEQUOTE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivative" ):
                listener.enterDerivative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivative" ):
                listener.exitDerivative(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDerivative" ):
                return visitor.visitDerivative(self)
            else:
                return visitor.visitChildren(self)


    class SlotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def slotExpression(self):
            return self.getTypedRuleContext(FoxySheepParser.SlotExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlot" ):
                listener.enterSlot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlot" ):
                listener.exitSlot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlot" ):
                return visitor.visitSlot(self)
            else:
                return visitor.visitChildren(self)


    class RightTeeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def RIGHTTEE(self):
            return self.getToken(FoxySheepParser.RIGHTTEE, 0)
        def DOUBLERIGHTTEE(self):
            return self.getToken(FoxySheepParser.DOUBLERIGHTTEE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightTee" ):
                listener.enterRightTee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightTee" ):
                listener.exitRightTee(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightTee" ):
                return visitor.visitRightTee(self)
            else:
                return visitor.visitChildren(self)


    class XorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def XOR(self):
            return self.getToken(FoxySheepParser.XOR, 0)
        def XNOR(self):
            return self.getToken(FoxySheepParser.XNOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXor" ):
                listener.enterXor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXor" ):
                listener.exitXor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXor" ):
                return visitor.visitXor(self)
            else:
                return visitor.visitChildren(self)


    class RuleContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def MINUSGREATER(self):
            return self.getToken(FoxySheepParser.MINUSGREATER, 0)
        def RARROW(self):
            return self.getToken(FoxySheepParser.RARROW, 0)
        def COLONGREATER(self):
            return self.getToken(FoxySheepParser.COLONGREATER, 0)
        def COLONARROW(self):
            return self.getToken(FoxySheepParser.COLONARROW, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule" ):
                listener.enterRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule" ):
                listener.exitRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRule" ):
                return visitor.visitRule(self)
            else:
                return visitor.visitChildren(self)


    class HeadExpressionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def LBRACKET(self):
            return self.getToken(FoxySheepParser.LBRACKET, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RBRACKET(self):
            return self.getToken(FoxySheepParser.RBRACKET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeadExpression" ):
                listener.enterHeadExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeadExpression" ):
                listener.exitHeadExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeadExpression" ):
                return visitor.visitHeadExpression(self)
            else:
                return visitor.visitChildren(self)


    class ReplaceAllContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SLASHDOT(self):
            return self.getToken(FoxySheepParser.SLASHDOT, 0)
        def DOUBLESLASHDOT(self):
            return self.getToken(FoxySheepParser.DOUBLESLASHDOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceAll" ):
                listener.enterReplaceAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceAll" ):
                listener.exitReplaceAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceAll" ):
                return visitor.visitReplaceAll(self)
            else:
                return visitor.visitChildren(self)


    class IntersectionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def INTERSECTION(self):
            return self.getToken(FoxySheepParser.INTERSECTION, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection" ):
                listener.enterIntersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection" ):
                listener.exitIntersection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntersection" ):
                return visitor.visitIntersection(self)
            else:
                return visitor.visitChildren(self)


    class PreIncrementContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def DOUBLEPLUS(self):
            return self.getToken(FoxySheepParser.DOUBLEPLUS, 0)
        def DOUBLEMINUS(self):
            return self.getToken(FoxySheepParser.DOUBLEMINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreIncrement" ):
                listener.enterPreIncrement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreIncrement" ):
                listener.exitPreIncrement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreIncrement" ):
                return visitor.visitPreIncrement(self)
            else:
                return visitor.visitChildren(self)


    class IntegrateContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGRAL(self):
            return self.getToken(FoxySheepParser.INTEGRAL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DIFFERENTIALD(self):
            return self.getToken(FoxySheepParser.DIFFERENTIALD, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegrate" ):
                listener.enterIntegrate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegrate" ):
                listener.exitIntegrate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegrate" ):
                return visitor.visitIntegrate(self)
            else:
                return visitor.visitChildren(self)


    class SetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def EQUAL(self):
            return self.getToken(FoxySheepParser.EQUAL, 0)
        def COLONEQUAL(self):
            return self.getToken(FoxySheepParser.COLONEQUAL, 0)
        def CARETEQUAL(self):
            return self.getToken(FoxySheepParser.CARETEQUAL, 0)
        def CARETCOLONEQUAL(self):
            return self.getToken(FoxySheepParser.CARETCOLONEQUAL, 0)
        def FUNCTIONARROW(self):
            return self.getToken(FoxySheepParser.FUNCTIONARROW, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet" ):
                listener.enterSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet" ):
                listener.exitSet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSet" ):
                return visitor.visitSet(self)
            else:
                return visitor.visitChildren(self)


    class OpEqualsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def PLUSEQUAL(self):
            return self.getToken(FoxySheepParser.PLUSEQUAL, 0)
        def MINUSEQUAL(self):
            return self.getToken(FoxySheepParser.MINUSEQUAL, 0)
        def ASTERISKEQUAL(self):
            return self.getToken(FoxySheepParser.ASTERISKEQUAL, 0)
        def SLASHEQUAL(self):
            return self.getToken(FoxySheepParser.SLASHEQUAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpEquals" ):
                listener.enterOpEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpEquals" ):
                listener.exitOpEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpEquals" ):
                return visitor.visitOpEquals(self)
            else:
                return visitor.visitChildren(self)


    class MessageContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def DOUBLECOLON(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.DOUBLECOLON)
            else:
                return self.getToken(FoxySheepParser.DOUBLECOLON, i)
        def StringLiteral(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.StringLiteral)
            else:
                return self.getToken(FoxySheepParser.StringLiteral, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMessage" ):
                listener.enterMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMessage" ):
                listener.exitMessage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMessage" ):
                return visitor.visitMessage(self)
            else:
                return visitor.visitChildren(self)


    class CrossContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CROSS(self):
            return self.getToken(FoxySheepParser.CROSS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCross" ):
                listener.enterCross(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCross" ):
                listener.exitCross(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCross" ):
                return visitor.visitCross(self)
            else:
                return visitor.visitChildren(self)


    class PatternTestContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def QUESTIONMARK(self):
            return self.getToken(FoxySheepParser.QUESTIONMARK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternTest" ):
                listener.enterPatternTest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternTest" ):
                listener.exitPatternTest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternTest" ):
                return visitor.visitPatternTest(self)
            else:
                return visitor.visitChildren(self)


    class PrefixContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def AT(self):
            return self.getToken(FoxySheepParser.AT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefix" ):
                listener.enterPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefix" ):
                listener.exitPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefix" ):
                return visitor.visitPrefix(self)
            else:
                return visitor.visitChildren(self)


    class BackslashContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def RAWBACKSLASH(self):
            return self.getToken(FoxySheepParser.RAWBACKSLASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBackslash" ):
                listener.enterBackslash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBackslash" ):
                listener.exitBackslash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBackslash" ):
                return visitor.visitBackslash(self)
            else:
                return visitor.visitChildren(self)


    class RepeatedContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def DOUBLEDOT(self):
            return self.getToken(FoxySheepParser.DOUBLEDOT, 0)
        def TRIPPLEDOT(self):
            return self.getToken(FoxySheepParser.TRIPPLEDOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRepeated" ):
                listener.enterRepeated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRepeated" ):
                listener.exitRepeated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepeated" ):
                return visitor.visitRepeated(self)
            else:
                return visitor.visitChildren(self)


    class MapApplyContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def MAP(self):
            return self.getToken(FoxySheepParser.MAP, 0)
        def MAPALL(self):
            return self.getToken(FoxySheepParser.MAPALL, 0)
        def DOUBLEAT(self):
            return self.getToken(FoxySheepParser.DOUBLEAT, 0)
        def TRIPPLEAT(self):
            return self.getToken(FoxySheepParser.TRIPPLEAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapApply" ):
                listener.enterMapApply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapApply" ):
                listener.exitMapApply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMapApply" ):
                return visitor.visitMapApply(self)
            else:
                return visitor.visitChildren(self)


    class UnionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def UNION(self):
            return self.getToken(FoxySheepParser.UNION, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnion" ):
                listener.enterUnion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnion" ):
                listener.exitUnion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnion" ):
                return visitor.visitUnion(self)
            else:
                return visitor.visitChildren(self)


    class VerticalSeparatorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def VERTICALSEPARATOR(self):
            return self.getToken(FoxySheepParser.VERTICALSEPARATOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerticalSeparator" ):
                listener.enterVerticalSeparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerticalSeparator" ):
                listener.exitVerticalSeparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerticalSeparator" ):
                return visitor.visitVerticalSeparator(self)
            else:
                return visitor.visitChildren(self)


    class FactorialContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def BANG(self):
            return self.getToken(FoxySheepParser.BANG, 0)
        def DOUBLEBANG(self):
            return self.getToken(FoxySheepParser.DOUBLEBANG, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorial" ):
                listener.enterFactorial(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorial" ):
                listener.exitFactorial(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorial" ):
                return visitor.visitFactorial(self)
            else:
                return visitor.visitChildren(self)


    class SpanAContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLESEMICOLON(self):
            return self.getToken(FoxySheepParser.DOUBLESEMICOLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpanA" ):
                listener.enterSpanA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpanA" ):
                listener.exitSpanA(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpanA" ):
                return visitor.visitSpanA(self)
            else:
                return visitor.visitChildren(self)


    class FunctionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def AMP(self):
            return self.getToken(FoxySheepParser.AMP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction" ):
                listener.enterFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction" ):
                listener.exitFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction" ):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)


    class NumberContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numberLiteral(self):
            return self.getTypedRuleContext(FoxySheepParser.NumberLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)


    class StarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def STAR(self):
            return self.getToken(FoxySheepParser.STAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStar" ):
                listener.enterStar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStar" ):
                listener.exitStar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStar" ):
                return visitor.visitStar(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def EqualSymbol(self):
            return self.getToken(FoxySheepParser.EqualSymbol, 0)
        def NotEqualSymbol(self):
            return self.getToken(FoxySheepParser.NotEqualSymbol, 0)
        def GreaterEqualSymbol(self):
            return self.getToken(FoxySheepParser.GreaterEqualSymbol, 0)
        def LessEqualSymbol(self):
            return self.getToken(FoxySheepParser.LessEqualSymbol, 0)
        def GREATER(self):
            return self.getToken(FoxySheepParser.GREATER, 0)
        def LESS(self):
            return self.getToken(FoxySheepParser.LESS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class TagSetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)

        def SLASHCOLON(self):
            return self.getToken(FoxySheepParser.SLASHCOLON, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def EQUAL(self):
            return self.getToken(FoxySheepParser.EQUAL, 0)
        def COLONEQUAL(self):
            return self.getToken(FoxySheepParser.COLONEQUAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTagSet" ):
                listener.enterTagSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTagSet" ):
                listener.exitTagSet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTagSet" ):
                return visitor.visitTagSet(self)
            else:
                return visitor.visitChildren(self)


    class IncrementContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def DOUBLEPLUS(self):
            return self.getToken(FoxySheepParser.DOUBLEPLUS, 0)
        def DOUBLEMINUS(self):
            return self.getToken(FoxySheepParser.DOUBLEMINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncrement" ):
                listener.enterIncrement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncrement" ):
                listener.exitIncrement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncrement" ):
                return visitor.visitIncrement(self)
            else:
                return visitor.visitChildren(self)


    class VerticalTildeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def VERTICALTILDE(self):
            return self.getToken(FoxySheepParser.VERTICALTILDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerticalTilde" ):
                listener.enterVerticalTilde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerticalTilde" ):
                listener.exitVerticalTilde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerticalTilde" ):
                return visitor.visitVerticalTilde(self)
            else:
                return visitor.visitChildren(self)


    class ColonContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def COLON(self):
            return self.getToken(FoxySheepParser.COLON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColon" ):
                listener.enterColon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColon" ):
                listener.exitColon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColon" ):
                return visitor.visitColon(self)
            else:
                return visitor.visitChildren(self)


    class SmallCircleContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SMALLCIRCLE(self):
            return self.getToken(FoxySheepParser.SMALLCIRCLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSmallCircle" ):
                listener.enterSmallCircle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSmallCircle" ):
                listener.exitSmallCircle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSmallCircle" ):
                return visitor.visitSmallCircle(self)
            else:
                return visitor.visitChildren(self)


    class ParenthesesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(FoxySheepParser.LPAREN, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def RPAREN(self):
            return self.getToken(FoxySheepParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParentheses" ):
                listener.enterParentheses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParentheses" ):
                listener.exitParentheses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParentheses" ):
                return visitor.visitParentheses(self)
            else:
                return visitor.visitChildren(self)


    class SpanBContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SPANSEMICOLONS(self):
            return self.getToken(FoxySheepParser.SPANSEMICOLONS, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLESEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.DOUBLESEMICOLON)
            else:
                return self.getToken(FoxySheepParser.DOUBLESEMICOLON, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpanB" ):
                listener.enterSpanB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpanB" ):
                listener.exitSpanB(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpanB" ):
                return visitor.visitSpanB(self)
            else:
                return visitor.visitChildren(self)


    class ConditionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def SLASHSEMI(self):
            return self.getToken(FoxySheepParser.SLASHSEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)


    class FloorContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LFLOOR(self):
            return self.getToken(FoxySheepParser.LFLOOR, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def RFLOOR(self):
            return self.getToken(FoxySheepParser.RFLOOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloor" ):
                listener.enterFloor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloor" ):
                listener.exitFloor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloor" ):
                return visitor.visitFloor(self)
            else:
                return visitor.visitChildren(self)


    class CompositionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def ATASTERISK(self):
            return self.getToken(FoxySheepParser.ATASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposition" ):
                listener.enterComposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposition" ):
                listener.exitComposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposition" ):
                return visitor.visitComposition(self)
            else:
                return visitor.visitChildren(self)


    class CircleDotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CIRCLEDOT(self):
            return self.getToken(FoxySheepParser.CIRCLEDOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCircleDot" ):
                listener.enterCircleDot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCircleDot" ):
                listener.exitCircleDot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCircleDot" ):
                return visitor.visitCircleDot(self)
            else:
                return visitor.visitChildren(self)


    class SymbolLiteralContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def symbol(self):
            return self.getTypedRuleContext(FoxySheepParser.SymbolContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolLiteral" ):
                listener.enterSymbolLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolLiteral" ):
                listener.exitSymbolLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolLiteral" ):
                return visitor.visitSymbolLiteral(self)
            else:
                return visitor.visitChildren(self)


    class CircleTimesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CIRCLETIMES(self):
            return self.getToken(FoxySheepParser.CIRCLETIMES, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCircleTimes" ):
                listener.enterCircleTimes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCircleTimes" ):
                listener.exitCircleTimes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCircleTimes" ):
                return visitor.visitCircleTimes(self)
            else:
                return visitor.visitChildren(self)


    class UnsetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def EQUAL(self):
            return self.getToken(FoxySheepParser.EQUAL, 0)
        def DOT(self):
            return self.getToken(FoxySheepParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnset" ):
                listener.enterUnset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnset" ):
                listener.exitUnset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnset" ):
                return visitor.visitUnset(self)
            else:
                return visitor.visitChildren(self)


    class DelContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DEL(self):
            return self.getToken(FoxySheepParser.DEL, 0)
        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDel" ):
                listener.enterDel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDel" ):
                listener.exitDel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDel" ):
                return visitor.visitDel(self)
            else:
                return visitor.visitChildren(self)


    class DiamondContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DIAMOND(self):
            return self.getToken(FoxySheepParser.DIAMOND, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiamond" ):
                listener.enterDiamond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiamond" ):
                listener.exitDiamond(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiamond" ):
                return visitor.visitDiamond(self)
            else:
                return visitor.visitChildren(self)


    class WedgeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def WEDGE(self):
            return self.getToken(FoxySheepParser.WEDGE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWedge" ):
                listener.enterWedge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWedge" ):
                listener.exitWedge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWedge" ):
                return visitor.visitWedge(self)
            else:
                return visitor.visitChildren(self)


    class PutContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(FoxySheepParser.ExprContext,0)

        def StringLiteral(self):
            return self.getToken(FoxySheepParser.StringLiteral, 0)
        def DOUBLEGREATER(self):
            return self.getToken(FoxySheepParser.DOUBLEGREATER, 0)
        def TRIPPLEGREATER(self):
            return self.getToken(FoxySheepParser.TRIPPLEGREATER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPut" ):
                listener.enterPut(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPut" ):
                listener.exitPut(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPut" ):
                return visitor.visitPut(self)
            else:
                return visitor.visitChildren(self)


    class StringJoinContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def LESSGREATER(self):
            return self.getToken(FoxySheepParser.LESSGREATER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringJoin" ):
                listener.enterStringJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringJoin" ):
                listener.exitStringJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringJoin" ):
                return visitor.visitStringJoin(self)
            else:
                return visitor.visitChildren(self)


    class TeeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def LEFTTEE(self):
            return self.getToken(FoxySheepParser.LEFTTEE, 0)
        def DOUBLELEFTTEE(self):
            return self.getToken(FoxySheepParser.DOUBLELEFTTEE, 0)
        def UPTEE(self):
            return self.getToken(FoxySheepParser.UPTEE, 0)
        def DOWNTEE(self):
            return self.getToken(FoxySheepParser.DOWNTEE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTee" ):
                listener.enterTee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTee" ):
                listener.exitTee(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTee" ):
                return visitor.visitTee(self)
            else:
                return visitor.visitChildren(self)


    class SetContainmentContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def ELEMENT(self):
            return self.getToken(FoxySheepParser.ELEMENT, 0)
        def NOTELEMENT(self):
            return self.getToken(FoxySheepParser.NOTELEMENT, 0)
        def SUBSET(self):
            return self.getToken(FoxySheepParser.SUBSET, 0)
        def SUPERSET(self):
            return self.getToken(FoxySheepParser.SUPERSET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetContainment" ):
                listener.enterSetContainment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetContainment" ):
                listener.exitSetContainment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetContainment" ):
                return visitor.visitSetContainment(self)
            else:
                return visitor.visitChildren(self)


    class VeeContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def VEE(self):
            return self.getToken(FoxySheepParser.VEE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVee" ):
                listener.enterVee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVee" ):
                listener.exitVee(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVee" ):
                return visitor.visitVee(self)
            else:
                return visitor.visitChildren(self)


    class CenterDotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CENTERDOT(self):
            return self.getToken(FoxySheepParser.CENTERDOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCenterDot" ):
                listener.enterCenterDot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCenterDot" ):
                listener.exitCenterDot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCenterDot" ):
                return visitor.visitCenterDot(self)
            else:
                return visitor.visitChildren(self)


    class TimesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def MultiplicationSymbol(self):
            return self.getToken(FoxySheepParser.MultiplicationSymbol, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimes" ):
                listener.enterTimes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimes" ):
                listener.exitTimes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimes" ):
                return visitor.visitTimes(self)
            else:
                return visitor.visitChildren(self)


    class StringExpressionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def DOUBLETILDE(self):
            return self.getToken(FoxySheepParser.DOUBLETILDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)


    class BracketingBarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACKETINGBAR(self):
            return self.getToken(FoxySheepParser.LBRACKETINGBAR, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RBRACKETINGBAR(self):
            return self.getToken(FoxySheepParser.RBRACKETINGBAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBracketingBar" ):
                listener.enterBracketingBar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBracketingBar" ):
                listener.exitBracketingBar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBracketingBar" ):
                return visitor.visitBracketingBar(self)
            else:
                return visitor.visitChildren(self)


    class CoproductContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def COPRODUCT(self):
            return self.getToken(FoxySheepParser.COPRODUCT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoproduct" ):
                listener.enterCoproduct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoproduct" ):
                listener.exitCoproduct(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCoproduct" ):
                return visitor.visitCoproduct(self)
            else:
                return visitor.visitChildren(self)


    class AngleBracketContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LANGLE(self):
            return self.getToken(FoxySheepParser.LANGLE, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RANGLE(self):
            return self.getToken(FoxySheepParser.RANGLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAngleBracket" ):
                listener.enterAngleBracket(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAngleBracket" ):
                listener.exitAngleBracket(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAngleBracket" ):
                return visitor.visitAngleBracket(self)
            else:
                return visitor.visitChildren(self)


    class PowerContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def CARET(self):
            return self.getToken(FoxySheepParser.CARET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPower" ):
                listener.enterPower(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPower" ):
                listener.exitPower(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPower" ):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = FoxySheepParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                localctx = FoxySheepParser.NumberContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 37
                self.numberLiteral()
                pass

            elif la_ == 2:
                localctx = FoxySheepParser.StringLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 38
                self.match(FoxySheepParser.StringLiteral)
                pass

            elif la_ == 3:
                localctx = FoxySheepParser.ParenthesesContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 39
                self.match(FoxySheepParser.LPAREN)
                self.state = 40
                self.expr(0)
                self.state = 41
                self.match(FoxySheepParser.RPAREN)
                pass

            elif la_ == 4:
                localctx = FoxySheepParser.ListContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 43
                self.match(FoxySheepParser.LBRACE)
                self.state = 44
                self.expressionList()
                self.state = 45
                self.match(FoxySheepParser.RBRACE)
                pass

            elif la_ == 5:
                localctx = FoxySheepParser.AngleBracketContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 47
                self.match(FoxySheepParser.LANGLE)
                self.state = 48
                self.expressionList()
                self.state = 49
                self.match(FoxySheepParser.RANGLE)
                pass

            elif la_ == 6:
                localctx = FoxySheepParser.FloorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 51
                self.match(FoxySheepParser.LFLOOR)
                self.state = 52
                self.expr(0)
                self.state = 53
                self.match(FoxySheepParser.RFLOOR)
                pass

            elif la_ == 7:
                localctx = FoxySheepParser.CeilingContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 55
                self.match(FoxySheepParser.LCEILING)
                self.state = 56
                self.expr(0)
                self.state = 57
                self.match(FoxySheepParser.RCEILING)
                pass

            elif la_ == 8:
                localctx = FoxySheepParser.BracketingBarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 59
                self.match(FoxySheepParser.LBRACKETINGBAR)
                self.state = 60
                self.expressionList()
                self.state = 61
                self.match(FoxySheepParser.RBRACKETINGBAR)
                pass

            elif la_ == 9:
                localctx = FoxySheepParser.DoubleBracketingBarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 63
                self.match(FoxySheepParser.LDOUBLEBRACKETINGBAR)
                self.state = 64
                self.expressionList()
                self.state = 65
                self.match(FoxySheepParser.RDOUBLEBRACKETINGBAR)
                pass

            elif la_ == 10:
                localctx = FoxySheepParser.SlotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 67
                self.slotExpression()
                pass

            elif la_ == 11:
                localctx = FoxySheepParser.OutContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 68
                self.outExpression()
                pass

            elif la_ == 12:
                localctx = FoxySheepParser.PatternBlanksContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 70
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==FoxySheepParser.Name or _la==FoxySheepParser.BACKQUOTE:
                    self.state = 69
                    self.symbol()


                self.state = 72
                _la = self._input.LA(1)
                if not(((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & ((1 << (FoxySheepParser.TRIPPLEBLANK - 77)) | (1 << (FoxySheepParser.DOUBLEBLANK - 77)) | (1 << (FoxySheepParser.BLANK - 77)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 74
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 73
                    self.expr(0)


                pass

            elif la_ == 13:
                localctx = FoxySheepParser.PatternBlankDotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 77
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==FoxySheepParser.Name or _la==FoxySheepParser.BACKQUOTE:
                    self.state = 76
                    self.symbol()


                self.state = 79
                self.match(FoxySheepParser.BLANKDOT)
                pass

            elif la_ == 14:
                localctx = FoxySheepParser.SymbolLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 80
                self.symbol()
                pass

            elif la_ == 15:
                localctx = FoxySheepParser.GetContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 81
                self.match(FoxySheepParser.DOUBLELESS)
                self.state = 82
                self.match(FoxySheepParser.StringLiteral)
                pass

            elif la_ == 16:
                localctx = FoxySheepParser.BoxConstructorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 83
                self.match(FoxySheepParser.BoxConstructor)
                self.state = 84
                self.expr(76)
                pass

            elif la_ == 17:
                localctx = FoxySheepParser.PreIncrementContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 85
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.DOUBLEPLUS or _la==FoxySheepParser.DOUBLEMINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 86
                self.expr(74)
                pass

            elif la_ == 18:
                localctx = FoxySheepParser.IntegrateContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 87
                self.match(FoxySheepParser.INTEGRAL)
                self.state = 88
                self.expr(0)
                self.state = 89
                self.match(FoxySheepParser.DIFFERENTIALD)
                self.state = 90
                self.expr(63)
                pass

            elif la_ == 19:
                localctx = FoxySheepParser.DelContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 92
                self.match(FoxySheepParser.DEL)
                self.state = 93
                self.expr(62)
                pass

            elif la_ == 20:
                localctx = FoxySheepParser.SquareContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 94
                self.match(FoxySheepParser.SQUARE)
                self.state = 95
                self.expr(61)
                pass

            elif la_ == 21:
                localctx = FoxySheepParser.UnaryPlusMinusContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 96
                _la = self._input.LA(1)
                if not(((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & ((1 << (FoxySheepParser.PLUS - 158)) | (1 << (FoxySheepParser.MINUS - 158)) | (1 << (FoxySheepParser.PLUSMINUS - 158)) | (1 << (FoxySheepParser.MINUSPLUS - 158)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 97
                self.expr(55)
                pass

            elif la_ == 22:
                localctx = FoxySheepParser.SpanBContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 98
                self.match(FoxySheepParser.SPANSEMICOLONS)
                self.state = 100
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 99
                    self.expr(0)


                self.state = 108
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 102
                        self.match(FoxySheepParser.DOUBLESEMICOLON)
                        self.state = 104
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
                        if la_ == 1:
                            self.state = 103
                            self.expr(0)

                 
                    self.state = 110
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

                pass

            elif la_ == 23:
                localctx = FoxySheepParser.NotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 111
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.NOT or _la==FoxySheepParser.BANG):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 112
                self.expr(30)
                pass

            elif la_ == 24:
                localctx = FoxySheepParser.PatternExpContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 113
                self.symbol()
                self.state = 114
                self.match(FoxySheepParser.RAWCOLON)
                self.state = 115
                self.expr(19)
                pass

            elif la_ == 25:
                localctx = FoxySheepParser.TagSetContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 117
                self.symbol()
                self.state = 118
                self.match(FoxySheepParser.SLASHCOLON)
                self.state = 119
                self.expr(0)
                self.state = 120
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.EQUAL or _la==FoxySheepParser.COLONEQUAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 121
                self.expr(4)
                pass

            elif la_ == 26:
                localctx = FoxySheepParser.TagUnsetContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 123
                self.symbol()
                self.state = 124
                self.match(FoxySheepParser.SLASHCOLON)
                self.state = 125
                self.expr(0)
                self.state = 126
                self.match(FoxySheepParser.EQUAL)
                self.state = 127
                self.match(FoxySheepParser.DOT)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 352
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 350
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                    if la_ == 1:
                        localctx = FoxySheepParser.PatternTestContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 131
                        if not self.precpred(self._ctx, 79):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 79)")
                        self.state = 132
                        self.match(FoxySheepParser.QUESTIONMARK)
                        self.state = 133
                        self.expr(80)
                        pass

                    elif la_ == 2:
                        localctx = FoxySheepParser.CompositionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 134
                        if not self.precpred(self._ctx, 73):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 73)")
                        self.state = 135
                        self.match(FoxySheepParser.ATASTERISK)
                        self.state = 136
                        self.expr(74)
                        pass

                    elif la_ == 3:
                        localctx = FoxySheepParser.RightCompositionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 137
                        if not self.precpred(self._ctx, 72):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 72)")
                        self.state = 138
                        self.match(FoxySheepParser.SLASHASTERISK)
                        self.state = 139
                        self.expr(73)
                        pass

                    elif la_ == 4:
                        localctx = FoxySheepParser.PrefixContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 140
                        if not self.precpred(self._ctx, 71):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 71)")
                        self.state = 141
                        self.match(FoxySheepParser.AT)
                        self.state = 142
                        self.expr(71)
                        pass

                    elif la_ == 5:
                        localctx = FoxySheepParser.InfixContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 143
                        if not self.precpred(self._ctx, 70):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 70)")
                        self.state = 144
                        self.match(FoxySheepParser.TILDE)
                        self.state = 145
                        self.expr(0)
                        self.state = 146
                        self.match(FoxySheepParser.TILDE)
                        self.state = 147
                        self.expr(71)
                        pass

                    elif la_ == 6:
                        localctx = FoxySheepParser.MapApplyContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 149
                        if not self.precpred(self._ctx, 69):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 69)")
                        self.state = 150
                        _la = self._input.LA(1)
                        if not(((((_la - 114)) & ~0x3f) == 0 and ((1 << (_la - 114)) & ((1 << (FoxySheepParser.TRIPPLEAT - 114)) | (1 << (FoxySheepParser.DOUBLEAT - 114)) | (1 << (FoxySheepParser.MAP - 114)) | (1 << (FoxySheepParser.MAPALL - 114)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 151
                        self.expr(69)
                        pass

                    elif la_ == 7:
                        localctx = FoxySheepParser.StringJoinContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 152
                        if not self.precpred(self._ctx, 65):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 65)")
                        self.state = 153
                        self.match(FoxySheepParser.LESSGREATER)
                        self.state = 154
                        self.expr(66)
                        pass

                    elif la_ == 8:
                        localctx = FoxySheepParser.PowerContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 155
                        if not self.precpred(self._ctx, 64):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 64)")
                        self.state = 156
                        self.match(FoxySheepParser.CARET)
                        self.state = 157
                        self.expr(64)
                        pass

                    elif la_ == 9:
                        localctx = FoxySheepParser.SmallCircleContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 158
                        if not self.precpred(self._ctx, 60):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 60)")
                        self.state = 159
                        self.match(FoxySheepParser.SMALLCIRCLE)
                        self.state = 160
                        self.expr(61)
                        pass

                    elif la_ == 10:
                        localctx = FoxySheepParser.CircleDotContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 161
                        if not self.precpred(self._ctx, 59):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 59)")
                        self.state = 162
                        self.match(FoxySheepParser.CIRCLEDOT)
                        self.state = 163
                        self.expr(60)
                        pass

                    elif la_ == 11:
                        localctx = FoxySheepParser.NonCommutativeMultiplyContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 164
                        if not self.precpred(self._ctx, 58):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 58)")
                        self.state = 165
                        self.match(FoxySheepParser.DOUBLEASTERISK)
                        self.state = 166
                        self.expr(59)
                        pass

                    elif la_ == 12:
                        localctx = FoxySheepParser.CrossContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 167
                        if not self.precpred(self._ctx, 57):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 57)")
                        self.state = 168
                        self.match(FoxySheepParser.CROSS)
                        self.state = 169
                        self.expr(58)
                        pass

                    elif la_ == 13:
                        localctx = FoxySheepParser.DotContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 170
                        if not self.precpred(self._ctx, 56):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 56)")
                        self.state = 171
                        self.match(FoxySheepParser.DOT)
                        self.state = 172
                        self.expr(57)
                        pass

                    elif la_ == 14:
                        localctx = FoxySheepParser.DivideContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 173
                        if not self.precpred(self._ctx, 54):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 54)")
                        self.state = 174
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.SLASH or _la==FoxySheepParser.DIVIDE):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 175
                        self.expr(55)
                        pass

                    elif la_ == 15:
                        localctx = FoxySheepParser.BackslashContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 176
                        if not self.precpred(self._ctx, 53):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 53)")
                        self.state = 177
                        self.match(FoxySheepParser.RAWBACKSLASH)
                        self.state = 178
                        self.expr(54)
                        pass

                    elif la_ == 16:
                        localctx = FoxySheepParser.DiamondContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 179
                        if not self.precpred(self._ctx, 52):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 52)")
                        self.state = 180
                        self.match(FoxySheepParser.DIAMOND)
                        self.state = 181
                        self.expr(53)
                        pass

                    elif la_ == 17:
                        localctx = FoxySheepParser.WedgeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 182
                        if not self.precpred(self._ctx, 51):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 51)")
                        self.state = 183
                        self.match(FoxySheepParser.WEDGE)
                        self.state = 184
                        self.expr(52)
                        pass

                    elif la_ == 18:
                        localctx = FoxySheepParser.VeeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 185
                        if not self.precpred(self._ctx, 50):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 50)")
                        self.state = 186
                        self.match(FoxySheepParser.VEE)
                        self.state = 187
                        self.expr(51)
                        pass

                    elif la_ == 19:
                        localctx = FoxySheepParser.CircleTimesContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 188
                        if not self.precpred(self._ctx, 49):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 49)")
                        self.state = 189
                        self.match(FoxySheepParser.CIRCLETIMES)
                        self.state = 190
                        self.expr(50)
                        pass

                    elif la_ == 20:
                        localctx = FoxySheepParser.CenterDotContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 191
                        if not self.precpred(self._ctx, 48):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 48)")
                        self.state = 192
                        self.match(FoxySheepParser.CENTERDOT)
                        self.state = 193
                        self.expr(49)
                        pass

                    elif la_ == 21:
                        localctx = FoxySheepParser.TimesContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 194
                        if not self.precpred(self._ctx, 47):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 47)")
                        self.state = 196
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==FoxySheepParser.MultiplicationSymbol:
                            self.state = 195
                            self.match(FoxySheepParser.MultiplicationSymbol)


                        self.state = 198
                        self.expr(48)
                        pass

                    elif la_ == 22:
                        localctx = FoxySheepParser.StarContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 199
                        if not self.precpred(self._ctx, 46):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 46)")
                        self.state = 200
                        self.match(FoxySheepParser.STAR)
                        self.state = 201
                        self.expr(47)
                        pass

                    elif la_ == 23:
                        localctx = FoxySheepParser.VerticalTildeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 202
                        if not self.precpred(self._ctx, 45):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 45)")
                        self.state = 203
                        self.match(FoxySheepParser.VERTICALTILDE)
                        self.state = 204
                        self.expr(46)
                        pass

                    elif la_ == 24:
                        localctx = FoxySheepParser.CoproductContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 205
                        if not self.precpred(self._ctx, 44):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 44)")
                        self.state = 206
                        self.match(FoxySheepParser.COPRODUCT)
                        self.state = 207
                        self.expr(45)
                        pass

                    elif la_ == 25:
                        localctx = FoxySheepParser.CapContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 208
                        if not self.precpred(self._ctx, 43):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 43)")
                        self.state = 209
                        self.match(FoxySheepParser.CAP)
                        self.state = 210
                        self.expr(44)
                        pass

                    elif la_ == 26:
                        localctx = FoxySheepParser.CupContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 211
                        if not self.precpred(self._ctx, 42):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 42)")
                        self.state = 212
                        self.match(FoxySheepParser.CUP)
                        self.state = 213
                        self.expr(43)
                        pass

                    elif la_ == 27:
                        localctx = FoxySheepParser.CirclePlusContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 214
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 215
                        self.match(FoxySheepParser.CIRCLEPLUS)
                        self.state = 216
                        self.expr(42)
                        pass

                    elif la_ == 28:
                        localctx = FoxySheepParser.CircleMinusContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 217
                        if not self.precpred(self._ctx, 40):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 40)")
                        self.state = 218
                        self.match(FoxySheepParser.CIRCLEMINUS)
                        self.state = 219
                        self.expr(41)
                        pass

                    elif la_ == 29:
                        localctx = FoxySheepParser.PlusOpContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 220
                        if not self.precpred(self._ctx, 39):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 39)")
                        self.state = 221
                        _la = self._input.LA(1)
                        if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (FoxySheepParser.BINARYPLUS - 182)) | (1 << (FoxySheepParser.BINARYMINUS - 182)) | (1 << (FoxySheepParser.BINARYMINUSPLUS - 182)) | (1 << (FoxySheepParser.BINARYPLUSMINUS - 182)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 222
                        self.expr(40)
                        pass

                    elif la_ == 30:
                        localctx = FoxySheepParser.IntersectionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 223
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 224
                        self.match(FoxySheepParser.INTERSECTION)
                        self.state = 225
                        self.expr(39)
                        pass

                    elif la_ == 31:
                        localctx = FoxySheepParser.UnionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 226
                        if not self.precpred(self._ctx, 37):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 37)")
                        self.state = 227
                        self.match(FoxySheepParser.UNION)
                        self.state = 228
                        self.expr(38)
                        pass

                    elif la_ == 32:
                        localctx = FoxySheepParser.ComparisonContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 229
                        if not self.precpred(self._ctx, 34):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 34)")
                        self.state = 230
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.EqualSymbol) | (1 << FoxySheepParser.NotEqualSymbol) | (1 << FoxySheepParser.GreaterEqualSymbol) | (1 << FoxySheepParser.LessEqualSymbol) | (1 << FoxySheepParser.LESS) | (1 << FoxySheepParser.GREATER))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 231
                        self.expr(35)
                        pass

                    elif la_ == 33:
                        localctx = FoxySheepParser.VerticalBarContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 232
                        if not self.precpred(self._ctx, 33):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 33)")
                        self.state = 233
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.VERTICALBAR) | (1 << FoxySheepParser.NOTVERTICALBAR) | (1 << FoxySheepParser.DOUBLEVERTICALBAR) | (1 << FoxySheepParser.NOTDOUBLEVERTICALBAR))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 234
                        self.expr(34)
                        pass

                    elif la_ == 34:
                        localctx = FoxySheepParser.SameContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 235
                        if not self.precpred(self._ctx, 32):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 32)")
                        self.state = 236
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.TRIPPLEEQUAL or _la==FoxySheepParser.EQUALBANGEQUAL):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 237
                        self.expr(33)
                        pass

                    elif la_ == 35:
                        localctx = FoxySheepParser.SetContainmentContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 238
                        if not self.precpred(self._ctx, 31):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 31)")
                        self.state = 239
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.ELEMENT) | (1 << FoxySheepParser.NOTELEMENT) | (1 << FoxySheepParser.SUBSET) | (1 << FoxySheepParser.SUPERSET))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 240
                        self.expr(32)
                        pass

                    elif la_ == 36:
                        localctx = FoxySheepParser.AndContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 241
                        if not self.precpred(self._ctx, 29):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 29)")
                        self.state = 242
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.DOUBLEAMP) | (1 << FoxySheepParser.AND) | (1 << FoxySheepParser.NAND))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 243
                        self.expr(30)
                        pass

                    elif la_ == 37:
                        localctx = FoxySheepParser.XorContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 244
                        if not self.precpred(self._ctx, 28):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 28)")
                        self.state = 245
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.XOR or _la==FoxySheepParser.XNOR):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 246
                        self.expr(29)
                        pass

                    elif la_ == 38:
                        localctx = FoxySheepParser.OrContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 247
                        if not self.precpred(self._ctx, 27):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 27)")
                        self.state = 248
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.DOUBLEBAR) | (1 << FoxySheepParser.OR) | (1 << FoxySheepParser.NOR))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 249
                        self.expr(28)
                        pass

                    elif la_ == 39:
                        localctx = FoxySheepParser.EquivalentContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 250
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 251
                        self.match(FoxySheepParser.LRDOUBLEARROW)
                        self.state = 252
                        self.expr(27)
                        pass

                    elif la_ == 40:
                        localctx = FoxySheepParser.ImpliesContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 253
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 254
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.RDOUBLEARROW or _la==FoxySheepParser.LCONTAINS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 255
                        self.expr(25)
                        pass

                    elif la_ == 41:
                        localctx = FoxySheepParser.RightTeeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 256
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 257
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.RIGHTTEE or _la==FoxySheepParser.DOUBLERIGHTTEE):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 258
                        self.expr(24)
                        pass

                    elif la_ == 42:
                        localctx = FoxySheepParser.TeeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 259
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 260
                        _la = self._input.LA(1)
                        if not(((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (FoxySheepParser.LEFTTEE - 67)) | (1 << (FoxySheepParser.DOUBLELEFTTEE - 67)) | (1 << (FoxySheepParser.UPTEE - 67)) | (1 << (FoxySheepParser.DOWNTEE - 67)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 261
                        self.expr(24)
                        pass

                    elif la_ == 43:
                        localctx = FoxySheepParser.SuchThatContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 262
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 263
                        self.match(FoxySheepParser.SUCHTHAT)
                        self.state = 264
                        self.expr(22)
                        pass

                    elif la_ == 44:
                        localctx = FoxySheepParser.AlternativesContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 265
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 266
                        self.match(FoxySheepParser.BAR)
                        self.state = 267
                        self.expr(21)
                        pass

                    elif la_ == 45:
                        localctx = FoxySheepParser.OptionalContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 268
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 269
                        self.match(FoxySheepParser.RAWCOLON)
                        self.state = 270
                        self.expr(19)
                        pass

                    elif la_ == 46:
                        localctx = FoxySheepParser.StringExpressionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 271
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 272
                        self.match(FoxySheepParser.DOUBLETILDE)
                        self.state = 273
                        self.expr(18)
                        pass

                    elif la_ == 47:
                        localctx = FoxySheepParser.ConditionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 274
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 275
                        self.match(FoxySheepParser.SLASHSEMI)
                        self.state = 276
                        self.expr(17)
                        pass

                    elif la_ == 48:
                        localctx = FoxySheepParser.RuleContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 277
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 278
                        _la = self._input.LA(1)
                        if not(((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (FoxySheepParser.MINUSGREATER - 87)) | (1 << (FoxySheepParser.RARROW - 87)) | (1 << (FoxySheepParser.COLONGREATER - 87)) | (1 << (FoxySheepParser.COLONARROW - 87)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 279
                        self.expr(15)
                        pass

                    elif la_ == 49:
                        localctx = FoxySheepParser.ReplaceAllContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 280
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 281
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.SLASHDOT or _la==FoxySheepParser.DOUBLESLASHDOT):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 282
                        self.expr(15)
                        pass

                    elif la_ == 50:
                        localctx = FoxySheepParser.OpEqualsContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 283
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 284
                        _la = self._input.LA(1)
                        if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (FoxySheepParser.PLUSEQUAL - 98)) | (1 << (FoxySheepParser.MINUSEQUAL - 98)) | (1 << (FoxySheepParser.ASTERISKEQUAL - 98)) | (1 << (FoxySheepParser.SLASHEQUAL - 98)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 285
                        self.expr(13)
                        pass

                    elif la_ == 51:
                        localctx = FoxySheepParser.ColonContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 286
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 287
                        self.match(FoxySheepParser.COLON)
                        self.state = 288
                        self.expr(12)
                        pass

                    elif la_ == 52:
                        localctx = FoxySheepParser.PostfixContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 289
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 290
                        self.match(FoxySheepParser.DOUBLESLASH)
                        self.state = 291
                        self.expr(11)
                        pass

                    elif la_ == 53:
                        localctx = FoxySheepParser.VerticalSeparatorContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 292
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 293
                        self.match(FoxySheepParser.VERTICALSEPARATOR)
                        self.state = 294
                        self.expr(10)
                        pass

                    elif la_ == 54:
                        localctx = FoxySheepParser.ThereforeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 295
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 296
                        self.match(FoxySheepParser.THEREFORE)
                        self.state = 297
                        self.expr(8)
                        pass

                    elif la_ == 55:
                        localctx = FoxySheepParser.BecauseContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 298
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 299
                        self.match(FoxySheepParser.BECAUSE)
                        self.state = 300
                        self.expr(8)
                        pass

                    elif la_ == 56:
                        localctx = FoxySheepParser.SetContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 301
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 302
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.EQUAL or ((((_la - 103)) & ~0x3f) == 0 and ((1 << (_la - 103)) & ((1 << (FoxySheepParser.CARETCOLONEQUAL - 103)) | (1 << (FoxySheepParser.COLONEQUAL - 103)) | (1 << (FoxySheepParser.CARETEQUAL - 103)) | (1 << (FoxySheepParser.FUNCTIONARROW - 103)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 303
                        self.expr(5)
                        pass

                    elif la_ == 57:
                        localctx = FoxySheepParser.MessageContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 304
                        if not self.precpred(self._ctx, 86):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 86)")
                        self.state = 305
                        self.match(FoxySheepParser.DOUBLECOLON)
                        self.state = 306
                        self.match(FoxySheepParser.StringLiteral)
                        self.state = 309
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                        if la_ == 1:
                            self.state = 307
                            self.match(FoxySheepParser.DOUBLECOLON)
                            self.state = 308
                            self.match(FoxySheepParser.StringLiteral)


                        pass

                    elif la_ == 58:
                        localctx = FoxySheepParser.HeadExpressionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 311
                        if not self.precpred(self._ctx, 78):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 78)")
                        self.state = 312
                        self.match(FoxySheepParser.LBRACKET)
                        self.state = 313
                        self.expressionList()
                        self.state = 314
                        self.match(FoxySheepParser.RBRACKET)
                        pass

                    elif la_ == 59:
                        localctx = FoxySheepParser.AccessorContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 316
                        if not self.precpred(self._ctx, 77):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 77)")
                        self.state = 317
                        self.accessExpression()
                        pass

                    elif la_ == 60:
                        localctx = FoxySheepParser.IncrementContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 318
                        if not self.precpred(self._ctx, 75):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 75)")
                        self.state = 319
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.DOUBLEPLUS or _la==FoxySheepParser.DOUBLEMINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                    elif la_ == 61:
                        localctx = FoxySheepParser.FactorialContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 320
                        if not self.precpred(self._ctx, 68):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 68)")
                        self.state = 321
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.DOUBLEBANG or _la==FoxySheepParser.BANG):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                    elif la_ == 62:
                        localctx = FoxySheepParser.ConjugateContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 322
                        if not self.precpred(self._ctx, 67):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 67)")
                        self.state = 323
                        _la = self._input.LA(1)
                        if not(((((_la - 132)) & ~0x3f) == 0 and ((1 << (_la - 132)) & ((1 << (FoxySheepParser.TRANSPOSE - 132)) | (1 << (FoxySheepParser.CONJUGATETRANSPOSE - 132)) | (1 << (FoxySheepParser.HERMITIANCONJUGATE - 132)) | (1 << (FoxySheepParser.CONJUGATE - 132)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                    elif la_ == 63:
                        localctx = FoxySheepParser.DerivativeContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 324
                        if not self.precpred(self._ctx, 66):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 66)")
                        self.state = 326 
                        self._errHandler.sync(self)
                        _alt = 1
                        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                            if _alt == 1:
                                self.state = 325
                                self.match(FoxySheepParser.SINGLEQUOTE)

                            else:
                                raise NoViableAltException(self)
                            self.state = 328 
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                        pass

                    elif la_ == 64:
                        localctx = FoxySheepParser.SpanAContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 330
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 331
                        self.match(FoxySheepParser.DOUBLESEMICOLON)
                        self.state = 333
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                        if la_ == 1:
                            self.state = 332
                            self.expr(0)


                        pass

                    elif la_ == 65:
                        localctx = FoxySheepParser.RepeatedContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 335
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 336
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.TRIPPLEDOT or _la==FoxySheepParser.DOUBLEDOT):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                    elif la_ == 66:
                        localctx = FoxySheepParser.FunctionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 337
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 338
                        self.match(FoxySheepParser.AMP)
                        pass

                    elif la_ == 67:
                        localctx = FoxySheepParser.UnsetContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 339
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 340
                        self.match(FoxySheepParser.EQUAL)
                        self.state = 341
                        self.match(FoxySheepParser.DOT)
                        pass

                    elif la_ == 68:
                        localctx = FoxySheepParser.PutContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 342
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 343
                        _la = self._input.LA(1)
                        if not(_la==FoxySheepParser.TRIPPLEGREATER or _la==FoxySheepParser.DOUBLEGREATER):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 344
                        self.match(FoxySheepParser.StringLiteral)
                        pass

                    elif la_ == 69:
                        localctx = FoxySheepParser.CompoundExpressionContext(self, FoxySheepParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 345
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 346
                        self.match(FoxySheepParser.SEMICOLON)
                        self.state = 348
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                        if la_ == 1:
                            self.state = 347
                            self.expr(0)


                        pass

             
                self.state = 354
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class SymbolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_symbol

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ContextNameContext(SymbolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SymbolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Name(self):
            return self.getToken(FoxySheepParser.Name, 0)
        def context(self):
            return self.getTypedRuleContext(FoxySheepParser.ContextContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextName" ):
                listener.enterContextName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextName" ):
                listener.exitContextName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContextName" ):
                return visitor.visitContextName(self)
            else:
                return visitor.visitChildren(self)



    def symbol(self):

        localctx = FoxySheepParser.SymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_symbol)
        try:
            localctx = FoxySheepParser.ContextNameContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 356
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 355
                self.context()


            self.state = 358
            self.match(FoxySheepParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_context

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleContextContext(ContextContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ContextContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Name(self):
            return self.getToken(FoxySheepParser.Name, 0)
        def BACKQUOTE(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.BACKQUOTE)
            else:
                return self.getToken(FoxySheepParser.BACKQUOTE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleContext" ):
                listener.enterSimpleContext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleContext" ):
                listener.exitSimpleContext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleContext" ):
                return visitor.visitSimpleContext(self)
            else:
                return visitor.visitChildren(self)


    class CompoundContextContext(ContextContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ContextContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.Name)
            else:
                return self.getToken(FoxySheepParser.Name, i)
        def BACKQUOTE(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.BACKQUOTE)
            else:
                return self.getToken(FoxySheepParser.BACKQUOTE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundContext" ):
                listener.enterCompoundContext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundContext" ):
                listener.exitCompoundContext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundContext" ):
                return visitor.visitCompoundContext(self)
            else:
                return visitor.visitChildren(self)



    def context(self):

        localctx = FoxySheepParser.ContextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_context)
        self._la = 0 # Token type
        try:
            self.state = 369
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                localctx = FoxySheepParser.SimpleContextContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 361
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==FoxySheepParser.BACKQUOTE:
                    self.state = 360
                    self.match(FoxySheepParser.BACKQUOTE)


                self.state = 363
                self.match(FoxySheepParser.Name)
                self.state = 364
                self.match(FoxySheepParser.BACKQUOTE)
                pass

            elif la_ == 2:
                localctx = FoxySheepParser.CompoundContextContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 365
                self.match(FoxySheepParser.Name)
                self.state = 366
                self.match(FoxySheepParser.BACKQUOTE)
                self.state = 367
                self.match(FoxySheepParser.Name)
                self.state = 368
                self.match(FoxySheepParser.BACKQUOTE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_numberLiteral

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NumberBaseNContext(NumberLiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.NumberLiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIGITS(self):
            return self.getToken(FoxySheepParser.DIGITS, 0)
        def NumberInBase(self):
            return self.getToken(FoxySheepParser.NumberInBase, 0)
        def numberLiteralPrecision(self):
            return self.getTypedRuleContext(FoxySheepParser.NumberLiteralPrecisionContext,0)

        def numberLiteralExponent(self):
            return self.getTypedRuleContext(FoxySheepParser.NumberLiteralExponentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberBaseN" ):
                listener.enterNumberBaseN(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberBaseN" ):
                listener.exitNumberBaseN(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberBaseN" ):
                return visitor.visitNumberBaseN(self)
            else:
                return visitor.visitChildren(self)


    class NumberBaseTenContext(NumberLiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.NumberLiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIGITS(self):
            return self.getToken(FoxySheepParser.DIGITS, 0)
        def DecimalNumber(self):
            return self.getToken(FoxySheepParser.DecimalNumber, 0)
        def numberLiteralPrecision(self):
            return self.getTypedRuleContext(FoxySheepParser.NumberLiteralPrecisionContext,0)

        def numberLiteralExponent(self):
            return self.getTypedRuleContext(FoxySheepParser.NumberLiteralExponentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberBaseTen" ):
                listener.enterNumberBaseTen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberBaseTen" ):
                listener.exitNumberBaseTen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberBaseTen" ):
                return visitor.visitNumberBaseTen(self)
            else:
                return visitor.visitChildren(self)



    def numberLiteral(self):

        localctx = FoxySheepParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_numberLiteral)
        self._la = 0 # Token type
        try:
            self.state = 386
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                localctx = FoxySheepParser.NumberBaseNContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 371
                self.match(FoxySheepParser.DIGITS)
                self.state = 372
                self.match(FoxySheepParser.NumberInBase)
                self.state = 374
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                if la_ == 1:
                    self.state = 373
                    self.numberLiteralPrecision()


                self.state = 377
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
                if la_ == 1:
                    self.state = 376
                    self.numberLiteralExponent()


                pass

            elif la_ == 2:
                localctx = FoxySheepParser.NumberBaseTenContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 379
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.DecimalNumber or _la==FoxySheepParser.DIGITS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 381
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 380
                    self.numberLiteralPrecision()


                self.state = 384
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 383
                    self.numberLiteralExponent()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralPrecisionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLEBACKQUOTE(self):
            return self.getToken(FoxySheepParser.DOUBLEBACKQUOTE, 0)

        def DecimalNumber(self):
            return self.getToken(FoxySheepParser.DecimalNumber, 0)

        def DIGITS(self):
            return self.getToken(FoxySheepParser.DIGITS, 0)

        def BACKQUOTE(self):
            return self.getToken(FoxySheepParser.BACKQUOTE, 0)

        def getRuleIndex(self):
            return FoxySheepParser.RULE_numberLiteralPrecision

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralPrecision" ):
                listener.enterNumberLiteralPrecision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralPrecision" ):
                listener.exitNumberLiteralPrecision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralPrecision" ):
                return visitor.visitNumberLiteralPrecision(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteralPrecision(self):

        localctx = FoxySheepParser.NumberLiteralPrecisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_numberLiteralPrecision)
        self._la = 0 # Token type
        try:
            self.state = 394
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FoxySheepParser.DOUBLEBACKQUOTE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 388
                self.match(FoxySheepParser.DOUBLEBACKQUOTE)
                self.state = 389
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.DecimalNumber or _la==FoxySheepParser.DIGITS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [FoxySheepParser.BACKQUOTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 390
                self.match(FoxySheepParser.BACKQUOTE)
                self.state = 392
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 391
                    _la = self._input.LA(1)
                    if not(_la==FoxySheepParser.DecimalNumber or _la==FoxySheepParser.DIGITS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralExponentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISKCARET(self):
            return self.getToken(FoxySheepParser.ASTERISKCARET, 0)

        def DIGITS(self):
            return self.getToken(FoxySheepParser.DIGITS, 0)

        def PLUS(self):
            return self.getToken(FoxySheepParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(FoxySheepParser.MINUS, 0)

        def getRuleIndex(self):
            return FoxySheepParser.RULE_numberLiteralExponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExponent" ):
                listener.enterNumberLiteralExponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExponent" ):
                listener.exitNumberLiteralExponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExponent" ):
                return visitor.visitNumberLiteralExponent(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteralExponent(self):

        localctx = FoxySheepParser.NumberLiteralExponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_numberLiteralExponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(FoxySheepParser.ASTERISKCARET)
            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==FoxySheepParser.PLUS or _la==FoxySheepParser.MINUS:
                self.state = 397
                _la = self._input.LA(1)
                if not(_la==FoxySheepParser.PLUS or _la==FoxySheepParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 400
            self.match(FoxySheepParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OutExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_outExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class OutUnnumberedContext(OutExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.OutExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTS(self):
            return self.getToken(FoxySheepParser.PERCENTS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutUnnumbered" ):
                listener.enterOutUnnumbered(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutUnnumbered" ):
                listener.exitOutUnnumbered(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutUnnumbered" ):
                return visitor.visitOutUnnumbered(self)
            else:
                return visitor.visitChildren(self)


    class OutNumberedContext(OutExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.OutExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTDIGITS(self):
            return self.getToken(FoxySheepParser.PERCENTDIGITS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutNumbered" ):
                listener.enterOutNumbered(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutNumbered" ):
                listener.exitOutNumbered(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutNumbered" ):
                return visitor.visitOutNumbered(self)
            else:
                return visitor.visitChildren(self)



    def outExpression(self):

        localctx = FoxySheepParser.OutExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_outExpression)
        try:
            self.state = 404
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FoxySheepParser.PERCENTDIGITS]:
                localctx = FoxySheepParser.OutNumberedContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 402
                self.match(FoxySheepParser.PERCENTDIGITS)
                pass
            elif token in [FoxySheepParser.PERCENTS]:
                localctx = FoxySheepParser.OutUnnumberedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 403
                self.match(FoxySheepParser.PERCENTS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlotExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_slotExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SlotDigitsContext(SlotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SlotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HASHDIGITS(self):
            return self.getToken(FoxySheepParser.HASHDIGITS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlotDigits" ):
                listener.enterSlotDigits(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlotDigits" ):
                listener.exitSlotDigits(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlotDigits" ):
                return visitor.visitSlotDigits(self)
            else:
                return visitor.visitChildren(self)


    class SlotSequenceDigitsContext(SlotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SlotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLEHASHDIGITS(self):
            return self.getToken(FoxySheepParser.DOUBLEHASHDIGITS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlotSequenceDigits" ):
                listener.enterSlotSequenceDigits(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlotSequenceDigits" ):
                listener.exitSlotSequenceDigits(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlotSequenceDigits" ):
                return visitor.visitSlotSequenceDigits(self)
            else:
                return visitor.visitChildren(self)


    class SlotNamedContext(SlotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SlotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HASHStringLiteral(self):
            return self.getToken(FoxySheepParser.HASHStringLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlotNamed" ):
                listener.enterSlotNamed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlotNamed" ):
                listener.exitSlotNamed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlotNamed" ):
                return visitor.visitSlotNamed(self)
            else:
                return visitor.visitChildren(self)


    class SlotSequenceContext(SlotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SlotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLEHASH(self):
            return self.getToken(FoxySheepParser.DOUBLEHASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlotSequence" ):
                listener.enterSlotSequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlotSequence" ):
                listener.exitSlotSequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlotSequence" ):
                return visitor.visitSlotSequence(self)
            else:
                return visitor.visitChildren(self)


    class SlotUnnamedContext(SlotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.SlotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HASH(self):
            return self.getToken(FoxySheepParser.HASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlotUnnamed" ):
                listener.enterSlotUnnamed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlotUnnamed" ):
                listener.exitSlotUnnamed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlotUnnamed" ):
                return visitor.visitSlotUnnamed(self)
            else:
                return visitor.visitChildren(self)



    def slotExpression(self):

        localctx = FoxySheepParser.SlotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_slotExpression)
        try:
            self.state = 411
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FoxySheepParser.HASHDIGITS]:
                localctx = FoxySheepParser.SlotDigitsContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 406
                self.match(FoxySheepParser.HASHDIGITS)
                pass
            elif token in [FoxySheepParser.HASHStringLiteral]:
                localctx = FoxySheepParser.SlotNamedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.match(FoxySheepParser.HASHStringLiteral)
                pass
            elif token in [FoxySheepParser.DOUBLEHASHDIGITS]:
                localctx = FoxySheepParser.SlotSequenceDigitsContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 408
                self.match(FoxySheepParser.DOUBLEHASHDIGITS)
                pass
            elif token in [FoxySheepParser.DOUBLEHASH]:
                localctx = FoxySheepParser.SlotSequenceContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 409
                self.match(FoxySheepParser.DOUBLEHASH)
                pass
            elif token in [FoxySheepParser.HASH]:
                localctx = FoxySheepParser.SlotUnnamedContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 410
                self.match(FoxySheepParser.HASH)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_expressionList

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExpressionListedContext(ExpressionListContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.ExpressionListContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FoxySheepParser.ExprContext)
            else:
                return self.getTypedRuleContext(FoxySheepParser.ExprContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.COMMA)
            else:
                return self.getToken(FoxySheepParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionListed" ):
                listener.enterExpressionListed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionListed" ):
                listener.exitExpressionListed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionListed" ):
                return visitor.visitExpressionListed(self)
            else:
                return visitor.visitChildren(self)



    def expressionList(self):

        localctx = FoxySheepParser.ExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_expressionList)
        self._la = 0 # Token type
        try:
            localctx = FoxySheepParser.ExpressionListedContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.Name) | (1 << FoxySheepParser.DecimalNumber) | (1 << FoxySheepParser.DIGITS) | (1 << FoxySheepParser.StringLiteral) | (1 << FoxySheepParser.LPAREN) | (1 << FoxySheepParser.LBRACE) | (1 << FoxySheepParser.LANGLE) | (1 << FoxySheepParser.LFLOOR) | (1 << FoxySheepParser.LCEILING) | (1 << FoxySheepParser.LBRACKETINGBAR) | (1 << FoxySheepParser.LDOUBLEBRACKETINGBAR) | (1 << FoxySheepParser.BACKQUOTE) | (1 << FoxySheepParser.DOUBLELESS) | (1 << FoxySheepParser.NOT))) != 0) or ((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & ((1 << (FoxySheepParser.TRIPPLEBLANK - 77)) | (1 << (FoxySheepParser.DOUBLEBLANK - 77)) | (1 << (FoxySheepParser.BLANKDOT - 77)) | (1 << (FoxySheepParser.BLANK - 77)) | (1 << (FoxySheepParser.PERCENTDIGITS - 77)) | (1 << (FoxySheepParser.PERCENTS - 77)) | (1 << (FoxySheepParser.HASHDIGITS - 77)) | (1 << (FoxySheepParser.HASHStringLiteral - 77)) | (1 << (FoxySheepParser.DOUBLEHASHDIGITS - 77)) | (1 << (FoxySheepParser.DOUBLEHASH - 77)) | (1 << (FoxySheepParser.HASH - 77)) | (1 << (FoxySheepParser.DOUBLEPLUS - 77)) | (1 << (FoxySheepParser.DOUBLEMINUS - 77)) | (1 << (FoxySheepParser.BANG - 77)) | (1 << (FoxySheepParser.INTEGRAL - 77)) | (1 << (FoxySheepParser.DEL - 77)) | (1 << (FoxySheepParser.SQUARE - 77)))) != 0) or ((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & ((1 << (FoxySheepParser.PLUS - 158)) | (1 << (FoxySheepParser.MINUS - 158)) | (1 << (FoxySheepParser.PLUSMINUS - 158)) | (1 << (FoxySheepParser.MINUSPLUS - 158)) | (1 << (FoxySheepParser.BoxConstructor - 158)) | (1 << (FoxySheepParser.SPANSEMICOLONS - 158)))) != 0):
                self.state = 413
                self.expr(0)


            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==FoxySheepParser.COMMA:
                self.state = 416
                self.match(FoxySheepParser.COMMA)
                self.state = 418
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FoxySheepParser.Name) | (1 << FoxySheepParser.DecimalNumber) | (1 << FoxySheepParser.DIGITS) | (1 << FoxySheepParser.StringLiteral) | (1 << FoxySheepParser.LPAREN) | (1 << FoxySheepParser.LBRACE) | (1 << FoxySheepParser.LANGLE) | (1 << FoxySheepParser.LFLOOR) | (1 << FoxySheepParser.LCEILING) | (1 << FoxySheepParser.LBRACKETINGBAR) | (1 << FoxySheepParser.LDOUBLEBRACKETINGBAR) | (1 << FoxySheepParser.BACKQUOTE) | (1 << FoxySheepParser.DOUBLELESS) | (1 << FoxySheepParser.NOT))) != 0) or ((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & ((1 << (FoxySheepParser.TRIPPLEBLANK - 77)) | (1 << (FoxySheepParser.DOUBLEBLANK - 77)) | (1 << (FoxySheepParser.BLANKDOT - 77)) | (1 << (FoxySheepParser.BLANK - 77)) | (1 << (FoxySheepParser.PERCENTDIGITS - 77)) | (1 << (FoxySheepParser.PERCENTS - 77)) | (1 << (FoxySheepParser.HASHDIGITS - 77)) | (1 << (FoxySheepParser.HASHStringLiteral - 77)) | (1 << (FoxySheepParser.DOUBLEHASHDIGITS - 77)) | (1 << (FoxySheepParser.DOUBLEHASH - 77)) | (1 << (FoxySheepParser.HASH - 77)) | (1 << (FoxySheepParser.DOUBLEPLUS - 77)) | (1 << (FoxySheepParser.DOUBLEMINUS - 77)) | (1 << (FoxySheepParser.BANG - 77)) | (1 << (FoxySheepParser.INTEGRAL - 77)) | (1 << (FoxySheepParser.DEL - 77)) | (1 << (FoxySheepParser.SQUARE - 77)))) != 0) or ((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & ((1 << (FoxySheepParser.PLUS - 158)) | (1 << (FoxySheepParser.MINUS - 158)) | (1 << (FoxySheepParser.PLUSMINUS - 158)) | (1 << (FoxySheepParser.MINUSPLUS - 158)) | (1 << (FoxySheepParser.BoxConstructor - 158)) | (1 << (FoxySheepParser.SPANSEMICOLONS - 158)))) != 0):
                    self.state = 417
                    self.expr(0)


                self.state = 424
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AccessExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FoxySheepParser.RULE_accessExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AccessExpressionBContext(AccessExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.AccessExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBARBRACKET(self):
            return self.getToken(FoxySheepParser.LBARBRACKET, 0)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RBARBRACKET(self):
            return self.getToken(FoxySheepParser.RBARBRACKET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessExpressionB" ):
                listener.enterAccessExpressionB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessExpressionB" ):
                listener.exitAccessExpressionB(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessExpressionB" ):
                return visitor.visitAccessExpressionB(self)
            else:
                return visitor.visitChildren(self)


    class AccessExpressionAContext(AccessExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FoxySheepParser.AccessExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACKET(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.LBRACKET)
            else:
                return self.getToken(FoxySheepParser.LBRACKET, i)
        def expressionList(self):
            return self.getTypedRuleContext(FoxySheepParser.ExpressionListContext,0)

        def RBRACKET(self, i:int=None):
            if i is None:
                return self.getTokens(FoxySheepParser.RBRACKET)
            else:
                return self.getToken(FoxySheepParser.RBRACKET, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessExpressionA" ):
                listener.enterAccessExpressionA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessExpressionA" ):
                listener.exitAccessExpressionA(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessExpressionA" ):
                return visitor.visitAccessExpressionA(self)
            else:
                return visitor.visitChildren(self)



    def accessExpression(self):

        localctx = FoxySheepParser.AccessExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_accessExpression)
        try:
            self.state = 435
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FoxySheepParser.LBRACKET]:
                localctx = FoxySheepParser.AccessExpressionAContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 425
                self.match(FoxySheepParser.LBRACKET)
                self.state = 426
                self.match(FoxySheepParser.LBRACKET)
                self.state = 427
                self.expressionList()
                self.state = 428
                self.match(FoxySheepParser.RBRACKET)
                self.state = 429
                self.match(FoxySheepParser.RBRACKET)
                pass
            elif token in [FoxySheepParser.LBARBRACKET]:
                localctx = FoxySheepParser.AccessExpressionBContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 431
                self.match(FoxySheepParser.LBARBRACKET)
                self.state = 432
                self.expressionList()
                self.state = 433
                self.match(FoxySheepParser.RBARBRACKET)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 79)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 73)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 72)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 71)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 70)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 69)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 65)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 64)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 60)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 59)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 58)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 57)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 56)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 54)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 53)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 52)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 51)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 50)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 49)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 48)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 47)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 46)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 45)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 44)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 43)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 42)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 40)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 39)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 30:
                return self.precpred(self._ctx, 37)
         

            if predIndex == 31:
                return self.precpred(self._ctx, 34)
         

            if predIndex == 32:
                return self.precpred(self._ctx, 33)
         

            if predIndex == 33:
                return self.precpred(self._ctx, 32)
         

            if predIndex == 34:
                return self.precpred(self._ctx, 31)
         

            if predIndex == 35:
                return self.precpred(self._ctx, 29)
         

            if predIndex == 36:
                return self.precpred(self._ctx, 28)
         

            if predIndex == 37:
                return self.precpred(self._ctx, 27)
         

            if predIndex == 38:
                return self.precpred(self._ctx, 26)
         

            if predIndex == 39:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 40:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 41:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 42:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 43:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 44:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 45:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 46:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 47:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 48:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 49:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 50:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 51:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 52:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 53:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 54:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 55:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 56:
                return self.precpred(self._ctx, 86)
         

            if predIndex == 57:
                return self.precpred(self._ctx, 78)
         

            if predIndex == 58:
                return self.precpred(self._ctx, 77)
         

            if predIndex == 59:
                return self.precpred(self._ctx, 75)
         

            if predIndex == 60:
                return self.precpred(self._ctx, 68)
         

            if predIndex == 61:
                return self.precpred(self._ctx, 67)
         

            if predIndex == 62:
                return self.precpred(self._ctx, 66)
         

            if predIndex == 63:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 64:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 65:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 66:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 67:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 68:
                return self.precpred(self._ctx, 1)
         




