/*
 * Copyright (c) 2015, Robert Jacobson
 * All rights reserved. 
 * 
 * Licensed under the BSD license. See LICENSE.txt for details.
 * 
 * Author(s): Robert Jacobson
 * 
 * Description: This class rewrites the parse tree generated by ANTLR4. 
 * 				It "flattens" flat operators that ANTLR parses as left 
 * 				associative.
 * 
 */

import java.io.FileInputStream;
import java.io.InputStream;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.TerminalNode;

/**
 * This class is a subclass of {@link FoxySheepBaseListener} that rewrites the
 * parse tree generated by ANTLR4. It "flattens" flat operators that ANTLR
 * parses as left associative.
 */
public class PostParser extends FoxySheepBaseListener {
	
	public static void main(String[] args) throws Exception{
		String inputFile = "/Users/rljacobson/Google Drive/Development/FoxySheep/Expression.txt";
		InputStream istream = new FileInputStream(inputFile);
		
		ANTLRInputStream input = new ANTLRInputStream(istream);
		FoxySheepLexer lexer = new FoxySheepLexer(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		FoxySheepParser parser = new FoxySheepParser(tokens);
		
		//Parse the input.
		ParseTree tree = parser.expr();
		
		//Emit FullForm.
		FullFormEmitter emitter = new FullFormEmitter();
		System.out.println( emitter.visit(tree));
				
		
		//Post process the parse tree (flatten flat operators).
		ParseTreeWalker walker = new ParseTreeWalker();
		PostParser postParser = new PostParser();
		walker.walk(postParser, tree);
		
		//Emit FullForm again.
		System.out.println( emitter.visit(tree));
		
//		System.out.println( "Done." );

	}
	
	/**
	 * {@inheritDoc}
	 *
	 * <p>This takes a ParserRuleContext of a binary operator and "flattens"
	 * the operator if one of its operands is the same binary operator context.</p>
	 */
	public void flatten(ParserRuleContext ctx){
		/* This function only flattens if the operator is the same and also 
		 * keeps the operators intact. 
		 *
		 * Since ANTLR4 parses this operator as left associative, we only
		 * need to check the left hand side expr.
		 */
		
		//If the child isn't the same construct, nothing to do.
		if(!(ctx.getChild(0).getClass() == ctx.getClass())) return;
		
		ParserRuleContext lhs = (ParserRuleContext)ctx.getChild(0);
		ParseTree rhs = ctx.getChild(2);
		TerminalNode op = (TerminalNode)ctx.getChild(1);
		
		/*If the operator of the nested Context isn't the same, nothing to do.
		 *The operator is always in position 1 for infix operators. We do this
		 *check because some Contexts that use the same context for multiple
		 *operators.
		*/
		if(  !op.getText().equals(lhs.getChild(1).getText()) ) return;
		
		//Clear all children.
		ctx.children.clear();

		//Add all children of lhs. (Also adds the operator of the lhs.)
		ctx.children.addAll(  lhs.children  );

		//Finally, add the rhs back in.
		ctx.children.add(rhs);
	}


	/**
	 * {@inheritDoc}
	 *
	 * <p>Inequality[]</p>
	 */
	@Override public void exitComparison(FoxySheepParser.ComparisonContext ctx) {
		/* This function flattens keeps the operators intact. It differs from 
		 * flatten() in that we flatten if the class is the same but don't check
		 * if the operator is the same. 
		 */
		
		//If the child isn't the same construct, nothing to do.
		if(!(ctx.getChild(0).getClass() == ctx.getClass())) return;
		
		ParserRuleContext lhs = (ParserRuleContext)ctx.getChild(0);
		ParseTree rhs = ctx.getChild(2);
		TerminalNode op = (TerminalNode)ctx.getChild(1);
		
		/*
		 * This is where we differ from flatten(). We don't do the following
		 * check.
		*/
		//if(  !op.getText().equals(lhs.getChild(1).getText()) ) return;
		
		ctx.children.clear();
		ctx.children.addAll(  lhs.children  );
		ctx.children.add(op); //We keep all operators intact.
		ctx.children.add(rhs);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Composition[expr1,expr2]	e@*e@*e.</p>
	 */
	@Override public void exitCompoundExpression(FoxySheepParser.CompoundExpressionContext ctx) {
		/* ANTLR4 parses this rule as right associative for some reason, so
		 * we cannot use flatten(). The code is actually much simpler than
		 * flatten because of the right associativity. 
		 */
		int childCount = ctx.getChildCount();
		
		//If there is no RHS, nothing to do.
		if(childCount < 3) return;
		//If the RHS child isn't the same construct, nothing to do.
		if( !(ctx.getChild(childCount-1).getClass() == ctx.getClass()) ) return;
		
		ParserRuleContext rhs = (ParserRuleContext)ctx.getChild(childCount-1);
		//Remove RHS child.
		ctx.removeLastChild();
		//Add all children of rhs. (Also adds the operator of the rhs.)
		ctx.children.addAll(  rhs.children  );
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Composition[expr1,expr2]	e@*e@*e.</p>
	 */
	@Override public void exitComposition(FoxySheepParser.CompositionContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>RightComposition[expr1,expr2]	e/*e/*e</p>
	 */
	@Override public void exitRightComposition(FoxySheepParser.RightCompositionContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>StringJoin[expr1,expr2]	e<>e<>e</p>
	 */
	@Override public void exitStringJoin(FoxySheepParser.StringJoinContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>SmallCircle[expr1,expr2]	eoeoe</p>
	 */
	@Override public void exitSmallCircle(FoxySheepParser.SmallCircleContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>CircleDot[expr1,expr2]		eoeoe</p>
	 */
	@Override public void exitCircleDot(FoxySheepParser.CircleDotContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>NonCommutativeMultiply[expr1,expr2]		e**e**e</p>
	 */
	@Override public void exitNonCommutativeMultiply(FoxySheepParser.NonCommutativeMultiplyContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Cross[expr1,expr2]		exexe</p>
	 */
	@Override public void exitCross(FoxySheepParser.CrossContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Dot[expr1,expr2]		e.e.e</p>
	 */
	@Override public void exitDot(FoxySheepParser.DotContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Diamond[expr1,expr2]		exexe</p>
	 */
	@Override public void exitDiamond(FoxySheepParser.DiamondContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Wedge[expr1,expr2]		eAeAe</p>
	 */
	@Override public void exitWedge(FoxySheepParser.WedgeContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>Vee[expr1,expr2]		eVeVe</p>
	 */
	@Override public void exitVee(FoxySheepParser.VeeContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>CircleTimes[expr1,expr2]		exexe</p>
	 */
	@Override public void exitCircleTimes(FoxySheepParser.CircleTimesContext ctx) {
		flatten(ctx);
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>CenterDot[expr1,expr2]		e.e.e</p>
	 */
	@Override public void exitCenterDot(FoxySheepParser.CenterDotContext ctx) {
		flatten(ctx);
	}
	
	/**
	 * {@inheritDoc}
	 *
	 * <p>Times[expr1,expr2]</p>
	 */
	@Override public void exitTimes(FoxySheepParser.TimesContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Star[expr1,expr2]</p>
	 */
	@Override public void exitStar(FoxySheepParser.StarContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>VerticalTilde[expr1,expr2]</p>
	 */
	@Override public void exitVerticalTilde(FoxySheepParser.VerticalTildeContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Coproduct[expr1,expr2]</p>
	 */
	@Override public void exitCoproduct(FoxySheepParser.CoproductContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Cap[expr1,expr2]</p>
	 */
	@Override public void exitCap(FoxySheepParser.CapContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Cup[expr1,expr2]</p>
	 */
	@Override public void exitCup(FoxySheepParser.CupContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>CirclePlus[expr1,expr2]</p>
	 */
	@Override public void exitCirclePlus(FoxySheepParser.CirclePlusContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>PlusOp[expr1,expr2]</p>
	 */
	@Override public void exitPlusOp(FoxySheepParser.PlusOpContext ctx) {
		/* We have to treat PlusOp special, because we only flatten if the operator
		 * is the same, and we also have to keep the operators intact. Also, only 
		 * plus and minus (not PlusMinus or MinusPlus) are flat.
		 */
		/* Since ANTLR4 parses this operator as left associative, we only
		 * need to check the left hand side expr.
		 */
		
		//If the child isn't a PlusOp, nothing to do.
		if(!(ctx.getChild(0) instanceof FoxySheepParser.PlusOpContext)) return;
		//If the op isn't Plus or Minus, nothing to do.
		if( ctx.BINARYMINUS()==null && ctx.BINARYPLUS()==null ) return;
		
		FoxySheepParser.PlusOpContext lhs = (FoxySheepParser.PlusOpContext)ctx.getChild(0);
		ParseTree rhs = ctx.getChild(2);
		TerminalNode op = (TerminalNode)ctx.getChild(1);
		
		//If the operator of the nested PlusOp isn't the same, nothing to do.
		if(  !op.getText().equals(lhs.getChild(1).getText()) ) return;
		
		//Clear all children.
		ctx.children.clear();

		//Add all children of lhs. (Also adds the operator of the lhs.)
		ctx.children.addAll(  lhs.children  );

		//Finally, add the rhs back in.
		ctx.children.add(rhs);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Intersection[expr1,expr2]</p>
	 */
	@Override public void exitIntersection(FoxySheepParser.IntersectionContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Union[expr1,expr2]</p>
	 */
	@Override public void exitUnion(FoxySheepParser.UnionContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>VerticalBar[expr1,expr2]</p>
	 */
	@Override public void exitVerticalBar(FoxySheepParser.VerticalBarContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Same[expr1,expr2]</p>
	 */
	@Override public void exitSame(FoxySheepParser.SameContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>SetContainment[expr1,expr2]</p>
	 */
	@Override public void exitSetContainment(FoxySheepParser.SetContainmentContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>And[expr1,expr2]</p>
	 */
	@Override public void exitAnd(FoxySheepParser.AndContext ctx) {
		//The usual flatten function won't work, because there are two And operators,
		//and we need to flatten over both.
		
		//If the child isn't the same construct, nothing to do.
		if(!(ctx.getChild(0).getClass() == ctx.getClass())) return;
		
		ParserRuleContext lhs = (ParserRuleContext)ctx.getChild(0);
		ParseTree rhs = ctx.getChild(2);
		TerminalNode op = (TerminalNode)ctx.getChild(1);
		
		/*If the operator of the nested Context isn't the same, nothing to do.
		 *The operator is always in position 1 for infix operators. We do this
		 *check because some Contexts that use the same context for multiple
		 *operators.
		*/
		//Here's the part that's different from flatten().
		//If childOp is an Nand or parentOp is a Nand, then we need child==parent.
		String childOp = lhs.getChild(1).getText();
		if(childOp.equals("\u22bc") || op.getText().equals("\u22bc")){
			if(  !op.getText().equals(childOp) ) return;
		}
		
		//Clear all children.
		ctx.children.clear();

		//Add all children of lhs. (Also adds the operator of the lhs.)
		ctx.children.addAll(  lhs.children  );

		//Finally, add the rhs back in.
		ctx.children.add(rhs);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Or[expr1,expr2]</p>
	 */
	@Override public void exitOr(FoxySheepParser.OrContext ctx) {
		//The usual flatten function won't work, because there are two Or operators,
		//and we need to flatten over both.
		
		//If the child isn't the same construct, nothing to do.
		if(!(ctx.getChild(0).getClass() == ctx.getClass())) return;
		
		ParserRuleContext lhs = (ParserRuleContext)ctx.getChild(0);
		ParseTree rhs = ctx.getChild(2);
		TerminalNode op = (TerminalNode)ctx.getChild(1);
		
		/*If the operator of the nested Context isn't the same, nothing to do.
		 *The operator is always in position 1 for infix operators. We do this
		 *check because some Contexts that use the same context for multiple
		 *operators.
		*/
		//Here's the part that's different from flatten().
		//If childOp is an Nor or parentOp is a Nor, then we need child==parent.
		String childOp = lhs.getChild(1).getText();
		if(childOp.equals("\u22bd") || op.getText().equals("\u22bd")){
			if(  !op.getText().equals(childOp) ) return;
		}
		
		//Clear all children.
		ctx.children.clear();

		//Add all children of lhs. (Also adds the operator of the lhs.)
		ctx.children.addAll(  lhs.children  );

		//Finally, add the rhs back in.
		ctx.children.add(rhs);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Or[expr1,expr2]</p>
	 */
	@Override public void exitXor(FoxySheepParser.XorContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Equivalent[expr1,expr2]</p>
	 */
	@Override public void exitEquivalent(FoxySheepParser.EquivalentContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Alternatives[expr1,expr2]</p>
	 */
	@Override public void exitAlternatives(FoxySheepParser.AlternativesContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>StringExpression[expr1,expr2]</p>
	 */
	@Override public void exitStringExpression(FoxySheepParser.StringExpressionContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>Colon[expr1,expr2]</p>
	 */
	@Override public void exitColon(FoxySheepParser.ColonContext ctx) {
		flatten(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>VerticalSeparator[expr1,expr2]</p>
	 */
	@Override public void exitVerticalSeparator(FoxySheepParser.VerticalSeparatorContext ctx) {
		flatten(ctx);
	}

}